<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面试-C++ - Felix Feng&#039;s Zone</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XU FENG&#039;S ZONE"><meta name="msapplication-TileImage" content="/images/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XU FENG&#039;S ZONE"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Abstract: 常见的C++面试题集合，包括Leetcode面试宝典、阅读整理、课堂资料等等。"><meta property="og:type" content="blog"><meta property="og:title" content="面试-C++"><meta property="og:url" content="https://2horse9sun.github.io/2021/04/25/2021-04-26-interview-C++/"><meta property="og:site_name" content="Felix Feng&#039;s Zone"><meta property="og:description" content="Abstract: 常见的C++面试题集合，包括Leetcode面试宝典、阅读整理、课堂资料等等。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://2horse9sun.github.io/images/banners/c++.jpg"><meta property="article:published_time" content="2021-04-25T16:00:00.000Z"><meta property="article:modified_time" content="2022-01-11T05:07:43.583Z"><meta property="article:author" content="Felix Feng"><meta property="article:tag" content="Interview"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/banners/c++.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://2horse9sun.github.io/2021/04/25/2021-04-26-interview-C++/"},"headline":"面试-C++","image":["https://2horse9sun.github.io/images/banners/c++.jpg"],"datePublished":"2021-04-25T16:00:00.000Z","dateModified":"2022-01-11T05:07:43.583Z","author":{"@type":"Person","name":"Felix Feng"},"publisher":{"@type":"Organization","name":"Felix Feng's Zone","logo":{"@type":"ImageObject","url":"https://2horse9sun.github.io/images/site-logo.png"}},"description":"Abstract: 常见的C++面试题集合，包括Leetcode面试宝典、阅读整理、课堂资料等等。"}</script><link rel="canonical" href="https://2horse9sun.github.io/2021/04/25/2021-04-26-interview-C++/"><link rel="icon" href="/images/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6295a3485ca71319f7c2bb6050180382";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Blog</a><a class="navbar-item" href="/categories/Project">Project</a><a class="navbar-item" href="/categories/Essay">Essay</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/banners/c++.jpg" alt="面试-C++"></span></div><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold">面试-C++</h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2021-04-25T16:00:00.000Z" title="2021/4/25 19:00:00">2021-04-25</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span><i class="fas fa-eye"></i><span>  </span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style=""><p>Abstract: 常见的C++面试题集合，包括Leetcode面试宝典、阅读整理、课堂资料等等。</p>
<span id="more"></span>

<p>Quick Link: <a href="https://2horse9sun.github.io/2021/04/15/interview-overview.html">面试-2021微信暑期实习</a></p>
<p>（非完整版~）</p>
<h2 id="1-C-基础"><a href="#1-C-基础" class="headerlink" title="1 C++基础"></a>1 C++基础</h2><h3 id="1-1-语言特性"><a href="#1-1-语言特性" class="headerlink" title="1.1 语言特性"></a>1.1 语言特性</h3><h4 id="1-1-1-C-11有哪些新特性"><a href="#1-1-1-C-11有哪些新特性" class="headerlink" title="1.1.1 C++11有哪些新特性"></a>1.1.1 C++11有哪些新特性</h4><ol>
<li><p>auto 类型推导<br>auto 关键字：<strong>自动类型推导</strong>，编译器会在 <strong>编译期间 通过初始值推导出变量的类型</strong>，通过 auto 定义的变量必须有初始值。</p>
<p>auto 关键字基本的使用语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = val1 + val2; <span class="comment">// 根据 val1 和 val2 相加的结果推断出 var 的类型，</span></span><br></pre></td></tr></table></figure>

<p>注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
</li>
<li><p>decltype 类型推导<br>decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。<strong>如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</strong>，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。<br>区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = val1 + val2; </span><br><span class="line"><span class="keyword">decltype</span>(val1 + val2) var1 = <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>auto 根据 = 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。<br>auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。</p>
</li>
<li><p><code>lambda</code> 表达式<br><code>lambda</code> 表达式，又被称为 <code>lambda</code> 函数或者 <code>lambda</code> 匿名函数。</p>
<p>lambda<strong>匿名函数</strong>的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type</span><br><span class="line">&#123;</span><br><span class="line">   function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。<br>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。<br>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行升序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(arr, arr+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>范围 <code>for</code> 语句<br>语法格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数的含义：</p>
<p>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string 等，这些类型的共同特点是<strong>拥有能返回迭代器的 beign、end 成员</strong>。<br>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。<br>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行结果为：</span></span><br><span class="line"><span class="comment">hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>右值引用<br>右值引用：绑定到右值的引用，用 <code>&amp;&amp;</code> 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。<br>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;l_var = var;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;r_var = var; <span class="comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;r_var2 = var + <span class="number">40</span>; <span class="comment">// 正确：将 r_var2 绑定到求和结果上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>标准库 move() 函数<br>move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>delete 函数和 default 函数</p>
<p>delete 函数：= delete 表示该函数不能被调用。<br>default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">// 表示使用默认的构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() = <span class="keyword">default</span>;	<span class="comment">// 表示使用默认的析构函数</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝构造</span></span><br><span class="line">	A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A ex1;</span><br><span class="line">	A ex2 = ex1; <span class="comment">// error: use of deleted function &#x27;A::A(const A&amp;)&#x27;</span></span><br><span class="line">	A ex3;</span><br><span class="line">	ex3 = ex1; <span class="comment">// error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-2-C-和-C-的区别"><a href="#1-1-2-C-和-C-的区别" class="headerlink" title="1.1.2 C 和 C++ 的区别"></a>1.1.2 C 和 C++ 的区别</h4><p>首先说一下面向对象和面向过程：</p>
<ol>
<li><strong>面向过程</strong>的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li>
<li><strong>面向对象</strong>的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li>
</ol>
<p>区别和联系：</p>
<ol>
<li><p><strong>语言自身</strong>：C 语言是面向过程的编程，它最重要的特点是函数，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</p>
</li>
<li><p><strong>应用领域</strong>：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</p>
</li>
<li><p>C++ 既继承了 C 强大的<strong>底层操作特性</strong>，又被赋予了<strong>面向对象机制</strong>。它特性繁多，面向对象语言的<strong>多继承</strong>，<strong>对值传递与引用传递的区分以及 const 关键字</strong>，等等。</p>
</li>
<li><p>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了<strong>面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）</strong>。</p>
</li>
</ol>
<h4 id="1-1-3-Java-和-C-的区别"><a href="#1-1-3-Java-和-C-的区别" class="headerlink" title="1.1.3 Java 和 C++ 的区别"></a>1.1.3 Java 和 C++ 的区别</h4><p>二者在语言特性上有很大的区别：</p>
<ol>
<li><strong>指针</strong>：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li>
<li><strong>多重继承</strong>：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li>
<li><strong>数据类型和类</strong>：Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li>
</ol>
<p><strong>垃圾回收</strong>：</p>
<ol>
<li>Java 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。</li>
<li>Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ol>
<li>Java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持。</li>
<li>C++ 可以直接编译成可执行文件，运行效率比 Java 高。</li>
<li>Java 主要用来开发 Web 应用。</li>
<li>C++ 主要用在嵌入式开发、网络、并发编程的方面。</li>
</ol>
<h4 id="1-1-4-Python-和-C-的区别"><a href="#1-1-4-Python-和-C-的区别" class="headerlink" title="1.1.4 Python 和 C++ 的区别"></a>1.1.4 Python 和 C++ 的区别</h4><p>区别：</p>
<ol>
<li><strong>语言自身</strong>：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li>
<li><strong>运行效率</strong>：C++ 运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机 CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li>
<li><strong>开发效率</strong>：Python 开发效率高。原因：Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li>
<li>书写格式和语法不同：Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</li>
</ol>
<h4 id="1-1-5-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"><a href="#1-1-5-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？" class="headerlink" title="1.1.5 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"></a>1.1.5 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</h4><p>左值：指表达式结束后依然存在的<strong>持久对象</strong>。</p>
<p>右值：表达式结束就不再存在的<strong>临时对象</strong>。</p>
<p>左值和右值的区别：左值持久，右值短暂</p>
<p>右值引用和左值引用的区别：</p>
<p><strong>左值引用不能绑定</strong>到要转换的表达式、字面常量或返回右值的<strong>表达式</strong>。<strong>右值引用</strong>恰好相反，<strong>可以绑定到这类表达式</strong>，但不能绑定到一个<strong>左值</strong>上。<br>右值引用必须绑定到右值的引用，通过 <strong>&amp;&amp;</strong> 获得。右值引用<strong>只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</strong><br><strong>std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值</strong>，以用于移动语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>&amp; tmp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;fun1(int&amp; tmp):&quot;</span> &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span>&amp;&amp; tmp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;fun2(int&amp;&amp; tmp)&quot;</span> &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">11</span>; </span><br><span class="line">  <span class="built_in">fun1</span>(<span class="number">12</span>); <span class="comment">// error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span></span><br><span class="line">  <span class="built_in">fun1</span>(var);</span><br><span class="line">  <span class="built_in">fun2</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-6-std-move-函数的实现原理"><a href="#1-1-6-std-move-函数的实现原理" class="headerlink" title="1.1.6 std::move() 函数的实现原理"></a>1.1.6 std::move() 函数的实现原理</h4><p><code>std::move()</code> 函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：引用折叠原理</p>
<p>右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。<br>左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。<br>小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。</p>
<p>remove_reference 具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始的，最通用的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义 T 的类型别名为 type</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//部分版本特例化，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt; <span class="comment">//左值引用</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&amp;&gt; <span class="comment">//右值引用</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;             <span class="comment">//使用原版本，</span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(i)&gt;::type  b;             <span class="comment">//左值引用特例版本</span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;::type  b;  <span class="comment">//右值引用特例版本 </span></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">转化过程：</span><br><span class="line"><span class="number">1.</span> std::<span class="built_in">move</span>(var) =&gt; std::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;&amp; &amp;) =&gt; 折叠后 std::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 此时：T 的类型为 <span class="keyword">int</span>&amp;，<span class="keyword">typename</span> remove_reference&lt;T&gt;::type 为 <span class="keyword">int</span>，这里使用 remove_reference 的左值引用的特例化版本</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 通过 <span class="keyword">static_cast</span> 将 <span class="keyword">int</span>&amp; 强制转换为 <span class="keyword">int</span>&amp;&amp;</span><br><span class="line"></span><br><span class="line">整个std::move被实例化如下</span><br><span class="line">string&amp;&amp; <span class="built_in">move</span>(<span class="keyword">int</span>&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>std::move() 实现原理：</p>
<ol>
<li>利用引用折叠原理将右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li>
<li>然后通过 remove_refrence 移除引用，得到具体的类型 T；</li>
<li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp; 右值引用。</li>
</ol>
<h4 id="1-1-7-什么是指针？指针的大小及用法？"><a href="#1-1-7-什么是指针？指针的大小及用法？" class="headerlink" title="1.1.7 什么是指针？指针的大小及用法？"></a>1.1.7 什么是指针？指针的大小及用法？</h4><p><strong>指针：</strong> 指向另外一种类型的复合类型。</p>
<p><strong>指针的大小：</strong> 在 64 位计算机中，指针占 8 个字节空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p1) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针的用法：</strong></p>
<ol>
<li><p>指向普通对象的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指向常量对象的指针：常量指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;c_var;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指向函数的指针：函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*fun_p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    fun_p = add;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_p</span>(<span class="number">1</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>特别注意：定义指向成员函数的指针时，<strong>要标明指针所属的类</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex;</span><br><span class="line">    ex.var1 = <span class="number">3</span>;</span><br><span class="line">    ex.var2 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;ex.var1; <span class="comment">// 指向对象成员变量的指针</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (A::*fun_p)();</span><br><span class="line">    fun_p = A::add; <span class="comment">// 指向对象成员函数的指针 fun_p</span></span><br><span class="line">    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this 指针：指向类的当前对象的指针常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(string tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_sex</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sex = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sex: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sex &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    p-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    p-&gt;<span class="built_in">set_age</span>(<span class="number">16</span>);</span><br><span class="line">    p-&gt;<span class="built_in">set_sex</span>(<span class="number">1</span>);</span><br><span class="line">    p-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-8-什么是野指针和悬空指针？"><a href="#1-1-8-什么是野指针和悬空指针？" class="headerlink" title="1.1.8 什么是野指针和悬空指针？"></a>1.1.8 什么是野指针和悬空指针？</h4><p>悬空指针：</p>
<p>若指针指向一块内存空间，当这块内存空间<strong>被释放后</strong>，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。<br>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line"><span class="comment">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span></span><br></pre></td></tr></table></figure>

<p>野指针：</p>
<p>“野指针”是指不确定其指向的指针，<strong>未初始化</strong>的指针为“野指针”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p; </span><br><span class="line"><span class="comment">// 此时 p 是“野指针”。</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-9-C-11-nullptr-比-NULL-优势"><a href="#1-1-9-C-11-nullptr-比-NULL-优势" class="headerlink" title="1.1.9 C++ 11 nullptr 比 NULL 优势"></a>1.1.9 C++ 11 nullptr 比 NULL 优势</h4><ol>
<li>NULL：预处理变量，是一个<strong>宏</strong>，它的<strong>值是 0</strong>，定义在头文件 <cstdlib> 中，即 #define NULL 0。</li>
<li>nullptr：C++ 11 中的关键字，是一种<strong>特殊类型</strong>的字面值，可以被转换成任意其他类型。</li>
</ol>
<p>nullptr 的优势：</p>
<ol>
<li><strong>有类型</strong>，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。</li>
<li><strong>函数重载</strong>：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，<strong>不知和哪一个函数匹配的情况</strong>；但是传递实参 nullptr 就不会出现这种情况。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(char const *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>); <span class="comment">// fun(char const *p)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    fun(NULL); // error: call of overloaded &#x27;fun(NULL)&#x27; is ambiguous</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-10-指针和引用的区别？"><a href="#1-1-10-指针和引用的区别？" class="headerlink" title="1.1.10 指针和引用的区别？"></a>1.1.10 指针和引用的区别？</h4><ol>
<li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（<strong>是否可变</strong>）</li>
<li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（<strong>是否占内存</strong>）</li>
<li>指针可以为空，但是引用必须绑定对象。（<strong>是否可为空</strong>）</li>
<li>指针可以有多级，但是引用只能一级。（<strong>是否能为多级</strong>）</li>
</ol>
<h4 id="1-1-11-常量指针和指针常量的区别"><a href="#1-1-11-常量指针和指针常量的区别" class="headerlink" title="1.1.11 常量指针和指针常量的区别"></a>1.1.11 常量指针和指针常量的区别</h4><p><strong>常量指针：</strong><br>常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>特点：const 的位置在<strong>指针声明运算符 * 的左侧</strong>。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p;</span><br></pre></td></tr></table></figure>

<p>注意 1：指针<strong>指向的对象不能通过这个指针来修改</strong>，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var; </span><br><span class="line">    *p = <span class="number">6</span>;            <span class="comment">// error: assignment of read-only location &#x27;* p&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 2：虽然常量指针指向的对象不能变化，可是因为<strong>常量指针本身是一个变量</strong>，因此，可以被重新赋值。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var1 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var2 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var1; </span><br><span class="line">    p = &amp;c_var2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针常量：</strong><br>指针常量的<strong>本质上是个常量</strong>，只不过这个<strong>常量的值是一个指针</strong>。<br>特点：<strong>const 位于指针声明操作符右侧</strong>，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> var;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var; </span><br></pre></td></tr></table></figure>

<p>注意 1：指针常量的值是指针，这个值因为是常量，所以<strong>指针本身不能改变</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var, var1;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    c_p = &amp;var1; <span class="comment">// error: assignment of read-only variable &#x27;c_p&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 2：<strong>指针指向的对象可以改变</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    *c_p = <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-12-函数指针和指针函数的区别"><a href="#1-1-12-函数指针和指针函数的区别" class="headerlink" title="1.1.12 函数指针和指针函数的区别"></a>1.1.12 函数指针和指针函数的区别</h4><p><strong>指针函数：</strong><br>指针函数本质是一个函数，只不过该<strong>函数的返回值是一个指针</strong>。相对于普通函数而言，只是返回值是指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> var1;</span><br><span class="line">  <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Type * <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span></span>&#123;</span><br><span class="line">    Type * t = <span class="keyword">new</span> <span class="built_in">Type</span>();</span><br><span class="line">    t-&gt;var1 = tmp1;</span><br><span class="line">    t-&gt;var2 = tmp2;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Type *p = <span class="built_in">fun</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针：</strong><br>函数指针本质是一个指针变量，只不过这个<strong>指针指向一个函数</strong>。函数指针即指向函数的指针。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 * tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 / tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); </span><br><span class="line">  fun = fun1;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl; </span><br><span class="line">  fun = fun2;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">75</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-13-强制类型转换有哪几种？"><a href="#1-1-13-强制类型转换有哪几种？" class="headerlink" title="1.1.13 强制类型转换有哪几种？"></a>1.1.13 强制类型转换有哪几种？</h4><p><strong>static_cast：</strong>用于数据的强制类型转换，<strong>强制将一种数据类型转换为另一种数据类型</strong>。</p>
<ol>
<li>用于<strong>基本数据类型</strong>的转换。</li>
<li>用于类层次之间的<strong>基类和派生类之间 指针或者引用 的转换</strong>（不要求必须包含虚函数，但必须是有相互联系的类），进行<strong>上行转换</strong>（派生类的指针或引用转换成基类表示）是<strong>安全</strong>的；进行<strong>下行转换</strong>（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是<strong>不安全的</strong>，<strong>最好用 dynamic_cast 进行下行转换</strong>。</li>
<li>可以将空指针<strong>转化成目标类型的空指针</strong>。</li>
<li>可以将任何类型的表达式<strong>转化成 void 类型</strong>。</li>
</ol>
<p><strong>const_cast：</strong>强制去掉常量属性，不能用于去掉变量的常量性，<strong>只能用于去除指针或引用的常量性</strong>，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p>
<p><strong>reinterpret_cast：</strong>将<strong>一种类型转换为另一种不同的类型</strong>。改变指针或引用的<strong>类型</strong>、将<strong>指针或引用</strong>转换为一个足够长度的整型、将整型转化为指针或引用类型。</p>
<p><strong>dynamic_cast：</strong></p>
<ol>
<li><p>其他三种都是编译时完成的，动态类型转换是在程序<strong>运行时处理</strong>的，运行时会<strong>进行类型检查</strong>。</p>
</li>
<li><p><strong>只能用于带有虚函数的基类或派生类的指针或者引用对象的转换</strong>，转换成功返回指向类型的指针或引用，<strong>转换失败返回 NULL</strong>；<strong>不能用于基本数据类型的转换</strong>。</p>
</li>
<li><p>在<strong>向上进行转换</strong>时，即派生类类的指针转换成基类类的指针<strong>和 static_cast 效果是一样</strong>的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    Derive *p2 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上类型转换</span></span><br><span class="line">    p1 = <span class="keyword">dynamic_cast</span>&lt;Base *&gt;(p2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<strong>下行转换</strong>时，基类的指针类型转化为派生类类的指针类型，<strong>只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    Base *p2 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derive *p3 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换成功</span></span><br><span class="line">    p3 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(p1);</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换失败</span></span><br><span class="line">    p3 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(p2);</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NOT NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-14-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？"><a href="#1-1-14-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？" class="headerlink" title="1.1.14 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？"></a>1.1.14 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</h4><p>需要重载操作符 == 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，<strong>字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</strong></p>
<p>利用运算符重载来实现结构体对象的比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">char</span> c_tmp, <span class="keyword">int</span> tmp) : <span class="built_in">c</span>(c_tmp), <span class="built_in">val</span>(tmp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2); <span class="comment">//  友元运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>, <span class="number">90</span>)</span>, <span class="title">ex2</span><span class="params">(<span class="string">&#x27;b&#x27;</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ex1 == ex2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ex1 == ex2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ex1 != ex2&quot;</span> &lt;&lt; endl; <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-15-参数传递时，值传递、引用传递、指针传递的区别？"><a href="#1-1-15-参数传递时，值传递、引用传递、指针传递的区别？" class="headerlink" title="1.1.15 参数传递时，值传递、引用传递、指针传递的区别？"></a>1.1.15 参数传递时，值传递、引用传递、指针传递的区别？</h4><p>参数传递的三种方式：</p>
<ol>
<li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li>
<li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li>
<li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>&#123; <span class="comment">// 值传递</span></span><br><span class="line">    cout &lt;&lt; &amp;tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> * tmp)</span></span>&#123; <span class="comment">// 指针传递</span></span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> &amp;tmp)</span></span>&#123; <span class="comment">// 引用传递</span></span><br><span class="line">    cout &lt;&lt; &amp;tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var 在主函数中的地址：&quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var 值传递时的地址：&quot;</span>;</span><br><span class="line">    <span class="built_in">fun1</span>(var);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var 指针传递时的地址：&quot;</span>;</span><br><span class="line">    <span class="built_in">fun2</span>(&amp;var);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var 引用传递时的地址：&quot;</span>;</span><br><span class="line">    <span class="built_in">fun3</span>(var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">var 在主函数中的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">var 值传递时的地址：0x23fe20</span></span><br><span class="line"><span class="comment">var 指针传递时的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">var 引用传递时的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-16-什么是模板？如何实现？"><a href="#1-1-16-什么是模板？如何实现？" class="headerlink" title="1.1.16 什么是模板？如何实现？"></a>1.1.16 什么是模板？如何实现？</h4><p>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。</p>
<ol>
<li>模板参数列表不能为空；</li>
<li>模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, ...&gt;</span><br></pre></td></tr></table></figure>

<p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p>
<ol>
<li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li>
<li>函数模板实例化：当调用一个模板时，<strong>编译器用函数实参来推断模板实参</strong>，从而使用实参的类型来确定绑定到模板参数的类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T &amp; tmp1, <span class="keyword">const</span> T &amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var1, var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> var3, var4;</span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，<strong>编译器不能为类模板推断模板参数类型</strong>，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c.a, <span class="keyword">this</span>-&gt;b + c.b)</span></span>;</span><br><span class="line">        cout &lt;&lt; tmp.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tmp.b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Complex&lt;<span class="keyword">int</span>&gt; c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-17-函数模板和类模板的区别？"><a href="#1-1-17-函数模板和类模板的区别？" class="headerlink" title="1.1.17 函数模板和类模板的区别？"></a>1.1.17 函数模板和类模板的区别？</h4><ol>
<li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显示指定。</li>
<li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li>
<li>默认参数：类模板在模板参数列表中可以有<strong>默认参数</strong>。</li>
<li>特化：函数模板只能全特化；而类模板可以全特化，也可以<strong>偏特化</strong>。</li>
<li>调用方式不同：函数模板可以隐式调用，也可以显示调用；类模板<strong>只能显示调用</strong>。</li>
</ol>
<p>函数模板调用方式举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T &amp; tmp1, <span class="keyword">const</span> T &amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    cout &lt;&lt; add_fun&lt;<span class="keyword">int</span>&gt;(var1, var2); <span class="comment">// 显示调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> var3, var4;</span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4); <span class="comment">// 隐式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-18-什么是可变参数模板？"><a href="#1-1-18-什么是可变参数模板？" class="headerlink" title="1.1.18 什么是可变参数模板？"></a>1.1.18 什么是可变参数模板？</h4><p>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p>
<ol>
<li>模板参数包：表示零个或多个模板参数；</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ol>
<p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="comment">// Args 是模板参数包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>; <span class="comment">// 可变参数模板，rest 是函数参数包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl; <span class="comment">// 最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">print_fun</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print_fun</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;wolrd&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">Hello worldd !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。</p>
<h4 id="1-1-19-什么是模板特化？为什么特化？"><a href="#1-1-19-什么是模板特化？为什么特化？" class="headerlink" title="1.1.19 什么是模板特化？为什么特化？"></a>1.1.19 什么是模板特化？为什么特化？</h4><p>模板特化的原因：<strong>模板并非对任何模板实参都合适、都能实例化</strong>，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义<strong>类或者函数模板的一个特例化版本</strong>。</p>
<p>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p>
<ol>
<li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li>
<li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li>
</ol>
<p>特化分为全特化和偏特化：</p>
<ol>
<li>全特化：模板中的模板参数全部特例化。</li>
<li>偏特化：模板中的<strong>模板参数只确定了一部分，剩余部分需要在编译器编译时确定</strong>。</li>
</ol>
<p>说明：要区分下函数重载与函数模板特化<br><strong>定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载</strong>，函数模板特化并不影响函数匹配。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通用版本：&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> t1 == t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">//函数模板特化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">char</span> *t1, <span class="keyword">char</span> *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;特化版本：&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(t1, t2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> arr2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">123</span>, <span class="number">123</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(arr1, arr2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">通用版本：1</span></span><br><span class="line"><span class="comment">特化版本：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-20-include-“-“-和-lt-gt-的区别"><a href="#1-1-20-include-“-“-和-lt-gt-的区别" class="headerlink" title="1.1.20 include “ “ 和 &lt;&gt; 的区别"></a>1.1.20 include “ “ 和 &lt;&gt; 的区别</h4><ol>
<li>查找文件的位置：include&lt;文件名&gt; 在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include”文件名” 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li>
<li>使用习惯：对于标准库中的头文件常用 include&lt;文件名&gt;，对于自己定义的头文件，常用 #include”文件名”</li>
</ol>
<h4 id="1-1-21-switch-的-case-里为何不能定义变量"><a href="#1-1-21-switch-的-case-里为何不能定义变量" class="headerlink" title="1.1.21 switch 的 case 里为何不能定义变量"></a>1.1.21 switch 的 case 里为何不能定义变量</h4><p>switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的，参考如下实例。<br>下述代码中，在 switch 的 case 中定义的变量，没有实际意义，仅为了解释上述原因。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="keyword">char</span> var = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (var)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 定义变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Excellent.&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; cnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        ++cnt;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Good.&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; cnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not bad.&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; cnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bad.&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; cnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bad.&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-22-迭代器的作用？"><a href="#1-1-22-迭代器的作用？" class="headerlink" title="1.1.22 迭代器的作用？"></a>1.1.22 迭代器的作用？</h4><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式。</p>
<p>作用：在无需知道容器底层原理的情况下，遍历容器中的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter = arr.<span class="built_in">begin</span>(); <span class="comment">// 定义迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (; iter != arr.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-23-泛型编程如何实现？"><a href="#1-1-23-泛型编程如何实现？" class="headerlink" title="1.1.23 泛型编程如何实现？"></a>1.1.23 泛型编程如何实现？</h4><p>一种语言机制，能够帮助实现一个通用的标准容器库。所谓通用的标准容器库，就是要能够做到，比如用一个List类存放所有可能类型的对象这样的事；泛型编程让你编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。</p>
<p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。</p>
<p>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p>
<ol>
<li>容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。</li>
<li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li>
<li>模板：可参考本章节中的模板相关问题。</li>
</ol>
<h4 id="1-1-24-什么是类型萃取？"><a href="#1-1-24-什么是类型萃取？" class="headerlink" title="1.1.24 什么是类型萃取？"></a>1.1.24 什么是类型萃取？</h4><p>类型萃取使用模板技术来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。</p>
<p>如STL中<code>copy()</code>的实现，根据容器内部所含对象的不同，选择不同复制方式。又如STL中的算法，根据迭代器种类的不同（单向，双向，随机），可使用不同算法实现来提高效率。</p>
<h3 id="1-2-编译与内存"><a href="#1-2-编译与内存" class="headerlink" title="1.2 编译与内存"></a>1.2 编译与内存</h3><h4 id="1-2-1-C-程序编译过程"><a href="#1-2-1-C-程序编译过程" class="headerlink" title="1.2.1 C++ 程序编译过程"></a>1.2.1 C++ 程序编译过程</h4><p><img src="/images/posts/c++_compile_step.jpg" alt="c++_compile_step"></p>
<p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</p>
<ol>
<li><strong>编译预处理</strong>：处理以 # 开头的指令；</li>
<li><strong>编译、优化</strong>：将源码 .cpp 文件翻译成 .s 汇编代码；</li>
<li><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令 .o 文件；</li>
<li><strong>链接</strong>：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</li>
</ol>
<p>链接分为两种：</p>
<ol>
<li><strong>静态链接</strong>：代码从其所在的<strong>静态链接库中拷贝到最终的可执行程序中</strong>，在该程序被执行时，这些<strong>代码会被装入到该进程的虚拟地址空间中</strong>。</li>
<li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中<strong>记录了共享对象的名字等一些信息</strong>。在<strong>程序执行时</strong>，<strong>动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间</strong>。</li>
</ol>
<p>二者的优缺点：</p>
<ol>
<li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要<strong>重新进行编译链接</strong>生成可执行程序（更新困难）；优点就是执行的时候<strong>运行速度快</strong>，因为可执行程序具备了程序运行的所有内容。</li>
<li>动态链接：<strong>节省内存、更新方便</strong>，但是动态链接是在程序运行时，每次执行都<strong>需要链接</strong>，相比静态链接会有一定的性能损失。</li>
</ol>
<h4 id="1-2-2-C-内存管理"><a href="#1-2-2-C-内存管理" class="headerlink" title="1.2.2 C++ 内存管理"></a>1.2.2 C++ 内存管理</h4><p><img src="/images/posts/memory_structure.png" alt="memory_structure"></p>
<p>C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p>
<ol>
<li>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li>
<li>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li>
<li>全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li>
<li>常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</li>
<li>代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">0</span>; <span class="comment">// g_var 在全局区（.data 段）</span></span><br><span class="line"><span class="keyword">char</span> *gp_var;  <span class="comment">// gp_var 在全局区（.bss 段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;                    <span class="comment">// var 在栈区</span></span><br><span class="line">    <span class="keyword">char</span> *p_var;                <span class="comment">// p_var 在栈区</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;abc&quot;</span>;         <span class="comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="keyword">char</span> *p_var1 = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var = <span class="number">0</span>;       <span class="comment">// s_var 为静态变量，存在静态存储区（.data 段）</span></span><br><span class="line">    p_var = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// 分配得来的 10 个字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">free</span>(p_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-栈和堆的区别"><a href="#1-2-3-栈和堆的区别" class="headerlink" title="1.2.3 栈和堆的区别"></a>1.2.3 栈和堆的区别</h4><ol>
<li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li>
<li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li>
<li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li>
<li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li>
<li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li>
</ol>
<h4 id="1-2-4-全局变量、局部变量、静态全局变量、静态局部变量的区别"><a href="#1-2-4-全局变量、局部变量、静态全局变量、静态局部变量的区别" class="headerlink" title="1.2.4 全局变量、局部变量、静态全局变量、静态局部变量的区别"></a>1.2.4 全局变量、局部变量、静态全局变量、静态局部变量的区别</h4><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<p>从作用域看：</p>
<ol>
<li>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以<strong>作用于所有的源文件</strong>。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。（外部链接性、静态持续变量）</li>
<li>静态全局变量：具有<strong>文件作用域</strong>。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个<strong>不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</strong>（内部链接性、静态持续变量）</li>
<li>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。（自动存储持续性的变量）</li>
<li>静态局部变量：具有局部作用域。它<strong>只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在</strong>，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。（无链接性、静态持续变量）</li>
</ol>
<p>从分配内存空间看：</p>
<ol>
<li>静态存储区：全局变量，静态局部变量，静态全局变量。</li>
<li>栈：局部变量。</li>
</ol>
<p>说明：</p>
<ol>
<li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li>
<li>静态变量和全局变量的区别：静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见。</li>
</ol>
<h4 id="1-2-5-全局变量定义在头文件中有什么问题？"><a href="#1-2-5-全局变量定义在头文件中有什么问题？" class="headerlink" title="1.2.5 全局变量定义在头文件中有什么问题？"></a>1.2.5 全局变量定义在头文件中有什么问题？</h4><p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能在头文件中定义全局变量。</p>
<p>#ifndef只防止重复include同一头文件，不同的文件include同一头文件是可以的；如果这个头文件里定义了全局变量，每个include该头文件的文件都会生成各自的同名全局变量，导致重复定义。</p>
<h4 id="1-2-6-如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"><a href="#1-2-6-如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？" class="headerlink" title="1.2.6 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"></a>1.2.6 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</h4><p>C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
<ol>
<li>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;</li>
<li>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</li>
</ol>
<p>限制对象只能建立在堆上：</p>
<ol>
<li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
</li>
<li><p>方法一：将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法存在的问题：</p>
<ol>
<li>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</li>
<li>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</li>
</ol>
</li>
<li><p>方法二：构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>限制对象只能建立在栈上：</p>
<p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-7-什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？"><a href="#1-2-7-什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？" class="headerlink" title="1.2.7 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？"></a>1.2.7 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</h4><p>内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中<br>内存对齐的原则：</p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li>
</ol>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：程序是在 64 位编译器下测试的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> var; <span class="comment">// 2 字节</span></span><br><span class="line">    <span class="keyword">int</span> var1;  <span class="comment">// 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8</span></span><br><span class="line">    <span class="keyword">long</span> var2; <span class="comment">// 12 字节 8 + 4 (long) = 12</span></span><br><span class="line">    <span class="keyword">char</span> var3; <span class="comment">// 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16</span></span><br><span class="line">    string s;  <span class="comment">// 48 字节 16 + 32 (string) = 48</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> var;</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">    <span class="keyword">long</span> var2;</span><br><span class="line">    <span class="keyword">char</span> var3;</span><br><span class="line">    string s;</span><br><span class="line">    A ex1;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(var) &lt;&lt; endl;  <span class="comment">// 2 short</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(var1) &lt;&lt; endl; <span class="comment">// 4 int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(var2) &lt;&lt; endl; <span class="comment">// 4 long</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(var3) &lt;&lt; endl; <span class="comment">// 1 char</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;    <span class="comment">// 32 string</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ex1) &lt;&lt; endl;  <span class="comment">// 48 struct</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p>
<ol>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ol>
<p>内存对齐的优点：</p>
<ol>
<li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li>
<li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li>
</ol>
<h4 id="1-2-8-类大小的计算"><a href="#1-2-8-类大小的计算" class="headerlink" title="1.2.8 类大小的计算"></a>1.2.8 类大小的计算</h4><p>说明：类的大小是指类的实例化对象的大小，用 <code>sizeof</code> 对类型名操作时，结果是该类型的对象的大小。</p>
<p>计算原则：</p>
<ol>
<li>遵循结构体的对齐原则。</li>
<li>与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li>
<li>虚函数对类的大小有影响，是因为<strong>虚函数表指针</strong>的影响。</li>
<li>虚继承对类的大小有影响，是因为虚基表指针带来的影响。</li>
<li>空类的大小是一个特殊情况，<strong>空类的大小为 1</strong>，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li>
</ol>
<p><strong>实例</strong>：<br>简单情况和空类情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：程序是在 64 位编译器下测试的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var; <span class="comment">// 不影响类的大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var;  <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="keyword">int</span> var;          <span class="comment">// 8 字节 4 + 4 (int) = 8</span></span><br><span class="line">    <span class="keyword">char</span> var1;        <span class="comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> temp) : <span class="built_in">c_var</span>(temp) &#123;&#125; <span class="comment">// 不影响类的大小</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;                    <span class="comment">// 不影响类的大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    B ex2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="comment">// 12 字节</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ex2) &lt;&lt; endl; <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带有虚函数的情况：（注意：虚函数的<strong>个数并不影响所占内存的大小</strong>，因为类对象的内存中只保存了指向虚函数表的指针。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：程序是在 64 位编译器下测试的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var; <span class="comment">// 不影响类的大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var;  <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="keyword">int</span> var;          <span class="comment">// 8 字节 4 + 4 (int) = 8</span></span><br><span class="line">    <span class="keyword">char</span> var1;        <span class="comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> temp) : <span class="built_in">c_var</span>(temp) &#123;&#125; <span class="comment">// 不影响类的大小</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;                      <span class="comment">// 不影响类的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::h&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    A *p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;   <span class="comment">// 8 字节 注意：指针所占的空间和指针指向的数据类型无关</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="comment">// 24 字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-9-什么是内存泄露"><a href="#1-2-9-什么是内存泄露" class="headerlink" title="1.2.9 什么是内存泄露"></a>1.2.9 什么是内存泄露</h4><p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p>
<p>进一步解释：</p>
<ol>
<li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li>
<li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li>
<li>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</li>
<li>指针重新赋值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>

<p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<h3 id="1-2-10-怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#1-2-10-怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="1.2.10 怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>1.2.10 怎么防止内存泄漏？内存泄漏检测工具的原理？</h3><p><strong>防止内存泄漏的方法：</strong></p>
<ol>
<li><p>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">1</span>) <span class="comment">// 构造函数中分配内存空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        p_size = n;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">A</span>() <span class="comment">// 析构函数中释放内存空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] p; <span class="comment">// 删除字符数组</span></span><br><span class="line">            p = <span class="literal">NULL</span>;   <span class="comment">// 防止出现野指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">GetPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> *p = ex.<span class="built_in">GetPointer</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况，请看如下程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    A ex1 = ex; </span><br><span class="line">    <span class="keyword">char</span> *p = ex.<span class="built_in">GetPointer</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单解释：对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间，但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况，只有当计数变量为 0 的时候才会释放该块内存空间，看如下程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">char</span> *p;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> p_size;</span><br><span class="line">     <span class="keyword">int</span> *p_count; <span class="comment">// 计数变量</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">1</span>) <span class="comment">// 在构造函数中申请内存</span></span><br><span class="line">     &#123;</span><br><span class="line">         p = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">         p_size = n;</span><br><span class="line">         p_count = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">         *p_count = <span class="number">1</span>;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;temp)</span><br><span class="line">     &#123;</span><br><span class="line">         p = temp.p;</span><br><span class="line">         p_size = temp.p_size;</span><br><span class="line">         p_count = temp.p_count;</span><br><span class="line">         (*p_count)++; <span class="comment">// 复制时，计数变量 +1</span></span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line">     ~<span class="built_in">A</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         (*p_count)--; <span class="comment">// 析构时，计数变量 -1</span></span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (*p_count == <span class="number">0</span>) <span class="comment">// 只有当计数变量为 0 的时候才会释放该块内存空间</span></span><br><span class="line">         &#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;buf is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="keyword">if</span> (p != <span class="literal">NULL</span>) </span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">delete</span>[] p; <span class="comment">// 删除字符数组</span></span><br><span class="line">                 p = <span class="literal">NULL</span>;   <span class="comment">// 防止出现野指针</span></span><br><span class="line">                 <span class="keyword">if</span> (p_count != <span class="literal">NULL</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">delete</span> p_count;</span><br><span class="line">                     p_count = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="function"><span class="keyword">char</span> *<span class="title">GetPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">     <span class="keyword">char</span> *p = ex.<span class="built_in">GetPointer</span>();</span><br><span class="line">     <span class="built_in">strcpy</span>(p, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">     cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     A ex1 = ex; <span class="comment">// 此时计数变量会 +1</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;ex1.p = &quot;</span> &lt;&lt; ex1.<span class="built_in">GetPointer</span>() &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">fun</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count is : <span class="number">1</span></span><br><span class="line">Test</span><br><span class="line">count is : <span class="number">2</span></span><br><span class="line">ex1.p = Test</span><br><span class="line">count is : <span class="number">1</span></span><br><span class="line">count is : <span class="number">0</span></span><br><span class="line">buf is deleted</span><br></pre></td></tr></table></figure>

<p>解释下：程序运行结果的倒数 2、3 行是调用两次析构函数时进行的操作，在第二次调用析构函数时，进行内存空间的释放，从而会有倒数第 1 行的输出结果。</p>
</li>
<li><p><strong>智能指针</strong><br>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。</p>
</li>
</ol>
<p><strong>内存泄漏检测工具的实现原理：</strong></p>
<p>内存检测工具有很多，这里重点介绍下 valgrind 。</p>
<p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p>
<ol>
<li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li>
<li>Callgrind：检查程序中函数调用过程中出现的问题。</li>
<li>Cachegrind：检查程序中缓存使用出现的问题。</li>
<li>Helgrind：检查多线程程序中出现的竞争问题。Massif：检查程序中堆栈使用中出现的问题。</li>
<li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li>
</ol>
<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p>
<ol>
<li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>
<li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>
</ol>
<p>检测原理：</p>
<ol>
<li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li>
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li>
</ol>
<h4 id="1-2-11-智能指针有哪几种？智能指针的实现原理？"><a href="#1-2-11-智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="1.2.11 智能指针有哪几种？智能指针的实现原理？"></a>1.2.11 智能指针有哪几种？智能指针的实现原理？</h4><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <memory> 头文件中。</p>
<p>C++11 中智能指针包括以下三种：</p>
<ol>
<li>共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li>
<li>独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值，目的是实现所有权的转移。</li>
<li>弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。</li>
</ol>
<p><strong>智能指针的实现原理：</strong> 计数原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">	T *_ptr;</span><br><span class="line">	<span class="keyword">size_t</span> *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			_count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SmartPtr</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">		<span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SmartPtr</span>(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 拷贝构造：计数 +1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">			<span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">			(*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SmartPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 赋值运算符重载 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) <span class="comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span></span><br><span class="line">		&#123;</span><br><span class="line">			(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">		(*<span class="keyword">this</span>-&gt;_count)++; <span class="comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">		<span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-12-使用智能指针会出现什么问题？怎么解决？"><a href="#1-2-12-使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="1.2.12 使用智能指针会出现什么问题？怎么解决？"></a>1.2.12 使用智能指针会出现什么问题？怎么解决？</h4><p>智能指针可能出现的问题：循环引用，比如在双向链表中。<br>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强引用和弱引用<br>一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>
<p>循环引用的解决方法： weak_ptr,   weak_ptr的出现就是为了辅助shared_ptr的工作，弥补shared_ptr的不足，解决shared_ptr造成的循环引用问题，而weak_ptr的这种解决方法也就是弱引用。</p>
<p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p>
<ol>
<li>weak_ptr 对被 shared_ptr 管理的对象存在 非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr；</li>
<li>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；<strong>令环中的指针之一为弱指针可以避免该情况</strong>；</li>
<li>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-关键字与库函数"><a href="#1-3-关键字与库函数" class="headerlink" title="1.3 关键字与库函数"></a>1.3 关键字与库函数</h3><h4 id="1-3-1-sizeof-和-strlen-的区别"><a href="#1-3-1-sizeof-和-strlen-的区别" class="headerlink" title="1.3.1 sizeof 和 strlen 的区别"></a>1.3.1 sizeof 和 strlen 的区别</h4><ol>
<li><p>strlen 是头文件 <cstring> 中的函数，sizeof 是 C++ 中的运算符。</p>
</li>
<li><p>strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束。而 sizeof 测量的是字符数组的分配大小。</p>
<p><code>strlen</code> 源代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++)</span><br><span class="line">        ++length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">size_of</span><span class="params">(<span class="keyword">char</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">size_of</span>(arr); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在<strong>编译时，计算长度</strong>；</p>
</li>
<li><p>sizeof 的<strong>参数可以是类型，也可以是变量</strong>；strlen 的参数必须是 char* 类型的变量。</p>
</li>
</ol>
<h3 id="1-3-2-lambda-表达式（匿名函数）的具体应用和使用场景"><a href="#1-3-2-lambda-表达式（匿名函数）的具体应用和使用场景" class="headerlink" title="1.3.2 lambda 表达式（匿名函数）的具体应用和使用场景"></a>1.3.2 lambda 表达式（匿名函数）的具体应用和使用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type</span><br><span class="line">&#123;</span><br><span class="line">   function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。<br>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</p>
<p><code>lambda</code> 表达式常搭配排序算法使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">90</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">// 降序排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：90 76 54 34 12 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-explicit-的作用（如何避免编译器进行隐式类型转换）"><a href="#1-3-3-explicit-的作用（如何避免编译器进行隐式类型转换）" class="headerlink" title="1.3.3 explicit 的作用（如何避免编译器进行隐式类型转换）"></a>1.3.3 explicit 的作用（如何避免编译器进行隐式类型转换）</h4><p>作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p>
<p>隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex = <span class="number">10</span>; <span class="comment">// 发生了隐式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，A ex = 10; 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：</p>
<p>为了避免隐式转换，可用 explicit 关键字进行声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    A ex1 = <span class="number">10</span>; <span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-static-的作用"><a href="#1-3-4-static-的作用" class="headerlink" title="1.3.4 static 的作用"></a>1.3.4 static 的作用</h4><ol>
<li><p>保持<strong>变量内容持久</strong>：<code>static</code> 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var = <span class="number">1</span>; <span class="comment">// var 只在第一次进入这个函数的时初始化</span></span><br><span class="line">    var += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> var;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    	cout &lt;&lt; <span class="built_in">fun</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>隐藏：static 作用于<strong>全局变量和函数</strong>，改变了全局变量和函数的作用域，使得全局变量和函数<strong>只能在定义它的文件中使用</strong>，在源文件中不具有全局可见性。（注：<strong>普通全局变量和函数具有全局可见性</strong>，即其他的源文件也可以使用。）</p>
</li>
<li><p>static 作用于<strong>类的成员变量和类的成员函数</strong>，使得类变量或者类成员函数和类有关，也就是说可以<strong>不定义类的对象就可以通过类访问这些静态成员</strong>。注意：类的<strong>静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var; <span class="comment">// 静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; s_var++ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; s_var &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span></span><br><span class="line">        <span class="comment">// show();  // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::s_var = <span class="number">1</span>;  <span class="comment">// 静态成员变量在类外进行初始化赋值，默认初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cout &lt;&lt; A::sa &lt;&lt; endl;    // error: &#x27;int A::sa&#x27; is private within this context</span></span><br><span class="line">    A ex;</span><br><span class="line">    ex.<span class="built_in">show</span>();</span><br><span class="line">    A::<span class="built_in">s_show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-3-5-★-static-在类中使用的注意事项（定义、初始化和使用）"><a href="#1-3-5-★-static-在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="1.3.5 ★ static 在类中使用的注意事项（定义、初始化和使用）"></a>1.3.5 ★ static 在类中使用的注意事项（定义、初始化和使用）</h4><p>static 静态成员变量：</p>
<ol>
<li><p><strong>静态成员变量是在类内进行声明，在类外进行定义和初始化</strong>，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则。</p>
</li>
<li><p>静态成员变量相当于类域中的全局变量，被<strong>类的所有对象所共享</strong>，包括派生类的对象。</p>
</li>
<li><p><strong>静态成员变量可以作为成员函数的参数，而普通成员变量不可以</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i = s_var)</span></span>; <span class="comment">// 正确，静态成员变量可以作为成员函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> i = var)</span></span>;   <span class="comment">//  error: invalid use of non-static data member &#x27;A::var&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>static 静态成员函数：</p>
<ol>
<li><strong>静态成员函数不能调用非静态成员变量或者非静态成员函数</strong>，因为静态成员函数<strong>没有 this 指针</strong>。静态成员函数做为类作用域的全局函数。</li>
<li>静态成员函数<strong>不能声明成虚函数（virtual）、const 函数和 volatile 函数</strong>。</li>
</ol>
<h3 id="1-3-6-static-全局变量和普通全局变量的异同"><a href="#1-3-6-static-全局变量和普通全局变量的异同" class="headerlink" title="1.3.6 static 全局变量和普通全局变量的异同"></a>1.3.6 static 全局变量和普通全局变量的异同</h3><p>相同点：</p>
<p>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</p>
<p>不同点：</p>
<ol>
<li>作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
<li>初始化：静态全局变量只初始化一次，防止在其他文件中使用。？？？</li>
</ol>
<h4 id="1-3-7-★-const-作用及用法"><a href="#1-3-7-★-const-作用及用法" class="headerlink" title="1.3.7 ★ const 作用及用法"></a>1.3.7 ★ const 作用及用法</h4><p>作用：</p>
<ol>
<li>const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li>
<li>const 修饰函数参数，使得<strong>传递过来的函数参数的值不能改变</strong>。</li>
<li>const 修饰成员函数，使得<strong>成员函数不能修改任何类型的成员变量</strong>（mutable 修饰的变量除外），也<strong>不能调用非 const 成员函数</strong>，因为非 const 成员函数可能会修改成员变量。</li>
</ol>
<p>在类中的用法：</p>
<p>const 成员变量：</p>
<ol>
<li><strong>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化</strong>。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</li>
</ol>
<p><code>const</code> 成员函数：</p>
<ol>
<li><strong>不能修改成员变量的值</strong>，除非有 <code>mutable</code> 修饰；只能访问成员变量。</li>
<li><strong>不能调用非常量成员函数</strong>，以防修改成员变量的值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> var;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">c_fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> <span class="keyword">const</span> <span class="comment">// const 成员函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		var = tmp; <span class="comment">// error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。		</span></span><br><span class="line">		<span class="built_in">fun</span>(tmp); <span class="comment">// error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		var = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-8-define-和-const-的区别"><a href="#1-3-8-define-和-const-的区别" class="headerlink" title="1.3.8 define 和 const 的区别"></a>1.3.8 define 和 const 的区别</h4><p>区别：</p>
<ol>
<li>编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</li>
<li>安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
<li>内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</li>
<li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。</li>
</ol>
<p><code>const</code> 的优点：</p>
<ol>
<li>有数据类型，在定义式可进行安全性检查。</li>
<li>可调式。</li>
<li>占用较少的空间。</li>
</ol>
<h4 id="1-3-9-define-和-typedef-的区别"><a href="#1-3-9-define-和-typedef-的区别" class="headerlink" title="1.3.9 define 和 typedef 的区别"></a>1.3.9 define 和 typedef 的区别</h4><ol>
<li>原理：#define 作为<strong>预处理指令</strong>，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是关键字，在编译时处理，有类型检查功能，用来<strong>给一个已经存在的类型一个别名</strong>，但不能在一个函数定义里面使用 typedef 。</li>
<li>功能：typedef 用来<strong>定义类型的别名</strong>，方便使用。#define <strong>不仅可以为类型取别名，还可以定义常量、变量、编译开关等</strong>。</li>
<li>作用域：#define <strong>没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef <strong>有自己的作用域。</strong></li>
<li>指针的操作：typedef 和 #define 在<strong>处理指针</strong>时不完全一样</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * INTPTR2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">// p1: int *; p2: int</span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">// p3: int *; p4: int *</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> INTPTR1 p5 = &amp;var; <span class="comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span></span><br><span class="line">    <span class="keyword">const</span> INTPTR2 p6 = &amp;var; <span class="comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-10-用宏实现比较大小，以及两个数中的最小值"><a href="#1-3-10-用宏实现比较大小，以及两个数中的最小值" class="headerlink" title="1.3.10 用宏实现比较大小，以及两个数中的最小值"></a>1.3.10 用宏实现比较大小，以及两个数中的最小值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">10</span>, var2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var1, var2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MIN</span>(var1, var2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-11-inline-作用、使用方法和原理"><a href="#1-3-11-inline-作用、使用方法和原理" class="headerlink" title="1.3.11 inline 作用、使用方法和原理"></a>1.3.11 inline 作用、使用方法和原理</h4><p>作用：<br>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p>
<p>使用方法：</p>
<ol>
<li><p><strong>类内定义成员函数默认是内联函数</strong><br>在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; </span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>类外定义成员函数，若想定义为内联函数，需用关键字声明</strong><br>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。</p>
</li>
</ol>
<p>原理：</p>
<ol>
<li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li>
<li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li>
</ol>
<h4 id="1-3-12-宏定义（define）和内联函数（inline）的区别"><a href="#1-3-12-宏定义（define）和内联函数（inline）的区别" class="headerlink" title="1.3.12  宏定义（define）和内联函数（inline）的区别"></a>1.3.12  宏定义（define）和内联函数（inline）的区别</h4><ol>
<li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li>
<li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li>
<li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fun_max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var, <span class="number">5</span>) &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_max</span>(var, <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-13-new-和-malloc-如何判断是否申请到内存？"><a href="#1-3-13-new-和-malloc-如何判断是否申请到内存？" class="headerlink" title="1.3.13 new 和 malloc 如何判断是否申请到内存？"></a>1.3.13 new 和 malloc 如何判断是否申请到内存？</h4><p>malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。<br>new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bac_alloc 异常。</p>
<h3 id="1-3-14-delete-实现原理？delete-和-delete-的区别？"><a href="#1-3-14-delete-实现原理？delete-和-delete-的区别？" class="headerlink" title="1.3.14 delete 实现原理？delete 和 delete[] 的区别？"></a>1.3.14 delete 实现原理？delete 和 delete[] 的区别？</h3><p><code>delete</code> 的实现原理：</p>
<ol>
<li>首先执行该对象所属类的析构函数；</li>
<li>进而通过调用 <code>operator delete()</code> 的标准库函数来释放所占的内存空间。</li>
</ol>
<p>delete 和 delete [] 的区别：</p>
<ol>
<li>delete 用来释放单个对象所占的空间，只会调用一次析构函数；</li>
<li>delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li>
</ol>
<h3 id="1-3-15-new-和-malloc-的区别，delete-和-free-的区别"><a href="#1-3-15-new-和-malloc-的区别，delete-和-free-的区别" class="headerlink" title="1.3.15 new 和 malloc 的区别，delete 和 free 的区别"></a>1.3.15 new 和 malloc 的区别，delete 和 free 的区别</h3><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p>
<ol>
<li>malloc、free 是库函数，而new、delete 是关键字。<br>new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。</li>
<li>new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li>
<li>new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。</li>
<li>对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。</li>
<li>new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）</li>
</ol>
<blockquote>
<p>堆区和自由存储区的区别与联系：<br>（1）malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放<br>（2）堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。<br>记住：<br>（1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。<br>（2）new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。<br>（3）堆和自由内存区有相同之处，但并不等价。</p>
</blockquote>
<h3 id="1-3-16-malloc-的原理？malloc-的底层实现？"><a href="#1-3-16-malloc-的原理？malloc-的底层实现？" class="headerlink" title="1.3.16 malloc 的原理？malloc 的底层实现？"></a>1.3.16 malloc 的原理？malloc 的底层实现？</h3><p><code>malloc()</code> 的原理:</p>
<ol>
<li>当开辟的空间小于 128K 时，调用 brk() 函数，通过移动 _enddata 来实现；</li>
<li>当开辟空间大于 128K 时，调用 mmap() 函数，通过在虚拟地址空间中开辟一块内存空间来实现。</li>
</ol>
<p><code>brk()</code> 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 <code>_enddata</code>。</p>
<p><code>mmap()</code> 内存映射原理：</p>
<ol>
<li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；</li>
<li>调用内核空间的系统调用函数 mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；</li>
<li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</li>
</ol>
<h4 id="1-3-17-C-和-C-struct-的区别？"><a href="#1-3-17-C-和-C-struct-的区别？" class="headerlink" title="1.3.17 C 和 C++ struct 的区别？"></a>1.3.17 C 和 C++ struct 的区别？</h4><ol>
<li>在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。</li>
<li>C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。</li>
<li>C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var;</li>
</ol>
<p>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 <code>struct</code>。</p>
<h4 id="1-3-18-struct-和-union-的区别"><a href="#1-3-18-struct-和-union-的区别" class="headerlink" title="1.3.18 struct 和 union 的区别"></a>1.3.18 struct 和 union 的区别</h4><p>说明：union 是联合体，struct 是结构体。<br>区别：</p>
<ol>
<li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li>
<li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li>
<li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> cc1; <span class="comment">// char 1 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// int 4 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// double 8 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u33;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 1（char）+ 1（char）= 2 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 2 + 6（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 16 + 1（char）+ 7（内存对齐）= 24 字节</span></span><br><span class="line">&#125; s33;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u11) &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u22) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u33) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s11) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s22) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s33) &lt;&lt; endl; <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;    <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-19-class-和-struct-的异同"><a href="#1-3-19-class-和-struct-的异同" class="headerlink" title="1.3.19 class 和 struct 的异同"></a>1.3.19 class 和 struct 的异同</h4><ol>
<li>struct 和 class 都可以自定义数据类型，也支持继承操作。</li>
<li>struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。</li>
<li>当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身， class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。</li>
<li><code>class</code> 可以用于定义模板参数，<code>struct</code> 不能用于定义模板参数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A&#123;&#125;; <span class="comment">// private 继承 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> B&#123;&#125;； <span class="comment">// public 继承</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A&#123; <span class="comment">// 由于 B 是 struct，A 的默认继承级别为 public</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> B&#123; <span class="comment">// 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A ex1;</span><br><span class="line">    ex1.<span class="built_in">funA</span>(); <span class="comment">// class A</span></span><br><span class="line"></span><br><span class="line">    B ex2;</span><br><span class="line">    ex2.<span class="built_in">funA</span>(); <span class="comment">// class A</span></span><br><span class="line">    ex2.<span class="built_in">funB</span>(); <span class="comment">// class B</span></span><br><span class="line"></span><br><span class="line">    C ex3;</span><br><span class="line">    ex3.<span class="built_in">funB</span>(); <span class="comment">// error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-20-volatile-的作用？是否具有原子性，对编译器有什么影响？"><a href="#1-3-20-volatile-的作用？是否具有原子性，对编译器有什么影响？" class="headerlink" title="1.3.20 volatile 的作用？是否具有原子性，对编译器有什么影响？"></a>1.3.20 volatile 的作用？是否具有原子性，对编译器有什么影响？</h4><ol>
<li>volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化。</li>
<li>volatile不具有原子性。</li>
<li>volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</li>
</ol>
<h4 id="1-3-21-什么情况下一定要用-volatile，-能否和-const-一起使用？"><a href="#1-3-21-什么情况下一定要用-volatile，-能否和-const-一起使用？" class="headerlink" title="1.3.21 什么情况下一定要用 volatile， 能否和 const 一起使用？"></a>1.3.21 什么情况下一定要用 volatile， 能否和 const 一起使用？</h4><p>使用 volatile 关键字的场景：</p>
<ol>
<li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰。</li>
</ol>
<p>volatile 关键字和 const 关键字可以同时使用，某种类型可以既是 volatile 又是 const ，同时具有二者的属性。</p>
<h4 id="1-3-22-extern-C-的作用？"><a href="#1-3-22-extern-C-的作用？" class="headerlink" title="1.3.22 extern C 的作用？"></a>1.3.22 extern C 的作用？</h4><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p>
<p>C++ 和 C语言编译函数签名方式不一样， extern关键字可以让两者保持统一，这样才能找到对应的函数.。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-23-sizeof-1-1-在-C-和-C-中分别是什么结果？"><a href="#1-3-23-sizeof-1-1-在-C-和-C-中分别是什么结果？" class="headerlink" title="1.3.23 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？"></a>1.3.23 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？</h4><p>C语言<br>sizeof（1 == 1） === sizeof（1）按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）<br>C++<br>因为有bool 类型<br>sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节</p>
<h4 id="1-3-24-★-memcpy和memmove-函数的底层原理？"><a href="#1-3-24-★-memcpy和memmove-函数的底层原理？" class="headerlink" title="1.3.24 ★ memcpy和memmove 函数的底层原理？"></a>1.3.24 ★ memcpy和memmove 函数的底层原理？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不保证拷贝正确性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">memcpy</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *d = dest;</span><br><span class="line">  <span class="keyword">char</span> *s = src;</span><br><span class="line">  <span class="keyword">if</span>(d == s) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">      *d++ = *s++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证拷贝正确性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">memmove</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *d = dest;</span><br><span class="line">  <span class="keyword">char</span> *s = src;</span><br><span class="line">  <span class="keyword">if</span>(d == s) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (d &lt; s)&#123;</span><br><span class="line">      <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">        *d++ = *s++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span>&#123;<span class="comment">// 从后往前拷贝</span></span><br><span class="line">      <span class="keyword">char</span> *lasts = s + (len<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">char</span> *lastd = d + (len<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">          *lastd-- = *lasts--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-25-strcpy-函数有什么缺陷？"><a href="#1-3-25-strcpy-函数有什么缺陷？" class="headerlink" title="1.3.25 strcpy 函数有什么缺陷？"></a>1.3.25 strcpy 函数有什么缺陷？</h4><p>strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">0x11112222</span>;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="comment">// 将变量 var 以 16 进制输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Address : var 0x23fe4c</span></span><br><span class="line"><span class="comment">Address : arr 0x23fe42</span></span><br><span class="line"><span class="comment">var:11002164</span></span><br><span class="line"><span class="comment">arr:hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：从上述代码中可以看出，变量 var 的后六位被字符串 “hello world!” 的 “d!\0” 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br>原因：变量 arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var 在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var 的内存空间，导致 var的后六位被覆盖。</p>
<h4 id="1-3-26-auto-类型推导的原理"><a href="#1-3-26-auto-类型推导的原理" class="headerlink" title="1.3.26 auto 类型推导的原理"></a>1.3.26 auto 类型推导的原理</h4><p>编译器根据初始值来推算变量的类型，要求用 auto 定义变量时必须有初始值。编译器推断出来的 auto 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p>
<h3 id="1-4-面向对象"><a href="#1-4-面向对象" class="headerlink" title="1.4 面向对象"></a>1.4 面向对象</h3><h4 id="1-4-1-什么是面向对象？面向对象的三大特性"><a href="#1-4-1-什么是面向对象？面向对象的三大特性" class="headerlink" title="1.4.1 什么是面向对象？面向对象的三大特性"></a>1.4.1 什么是面向对象？面向对象的三大特性</h4><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p>
<p>面向对象的三大特性：</p>
<ol>
<li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li>
<li>继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li>
<li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得<strong>基类指针呈现不同的表现方式</strong>。</li>
</ol>
<h4 id="1-4-2-重载、重写、隐藏的区别"><a href="#1-4-2-重载、重写、隐藏的区别" class="headerlink" title="1.4.2 重载、重写、隐藏的区别"></a>1.4.2 重载、重写、隐藏的区别</h4><p>重载：是指同一可访问区内被声明几个<strong>具有不同参数列（参数的类型、个数、顺序）的同名函数</strong>，根据参数列表确定调用哪个函数，重载<strong>不关心函数返回类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp)</span></span>;        <span class="comment">// 重载 参数类型不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span></span>; <span class="comment">// 重载 参数个数不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp, <span class="keyword">int</span> tmp1)</span></span>; <span class="comment">// 重载 参数顺序不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;            <span class="comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重写(覆盖)：是指<strong>派生类中存在重新定义的函数</strong>。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。<strong>重写的基类中被重写的函数必须有 virtual 修饰</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏：是指<strong>派生类的函数屏蔽了与其同名的基类函数</strong>，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。<strong>若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数</strong>。</p>
<p>重写和重载的区别：</p>
<ol>
<li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li>参数区别：<strong>重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型</strong>；重写的函数的函数名、参数列表和返回值类型都需要和原函数<strong>相同</strong>，父类中被<strong>重写的函数需要有 virtual 修饰</strong>。<br>virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li>
</ol>
<p>隐藏和重写，重载的区别：</p>
<ol>
<li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但<strong>函数名一定相同</strong>；当参数不同时，<strong>无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏</strong>，而不是重写。</li>
</ol>
<h4 id="1-4-3-什么是多态？多态如何实现？"><a href="#1-4-3-什么是多态？多态如何实现？" class="headerlink" title="1.4.3 什么是多态？多态如何实现？"></a>1.4.3 什么是多态？多态如何实现？</h4><p>多态：多态就是<strong>不同继承类的对象，对同一消息做出不同的响应</strong>，<strong>基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式</strong>。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。<br>实现方法：多态是通过<strong>虚函数实现</strong>的，<strong>虚函数的地址保存在虚函数表</strong>中，<strong>虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中</strong>。</p>
<p>实现过程：</p>
<ol>
<li>在类中用 virtual 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ol>
<p><img src="/images/posts/vtbl_1.png" alt="vtbl_1"></p>
<p><img src="/images/posts/vtbl_2.png" alt="vtbl_1"></p>
<p>当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 <code>Derive::f()</code> 进行调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	p-&gt;<span class="built_in">fun</span>(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-什么是虚函数？什么是纯虚函数？两者有何区别"><a href="#1-4-4-什么是虚函数？什么是纯虚函数？两者有何区别" class="headerlink" title="1.4.4 什么是虚函数？什么是纯虚函数？两者有何区别"></a>1.4.4 什么是虚函数？什么是纯虚函数？两者有何区别</h4><p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_fun</span><span class="params">()</span> <span class="comment">// 虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::v_fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">v_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::v_fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    p-&gt;<span class="built_in">v_fun</span>(); <span class="comment">// B::v_fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纯虚函数：</p>
<ol>
<li>纯虚函数在类中声明时，加上 =0；</li>
<li><strong>含有纯虚函数的类称为抽象类</strong>（只要含有纯虚函数这个类就是抽象类），<strong>类中只有接口，没有具体的实现方法</strong>；</li>
<li><strong>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象</strong>。</li>
</ol>
<p>说明：</p>
<ol>
<li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li><strong>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象</strong>。</li>
</ol>
<p>区别：</p>
<ol>
<li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（<strong>含有纯虚函数的类称为抽象基类</strong>）</li>
<li>使用方式不同：<strong>虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用</strong>；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;</li>
<li><strong>虚函数必须实现</strong>，否则编译器会报错；</li>
<li>对于<strong>实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数</strong>，虚函数和纯虚函数<strong>都可以在派生类中重写</strong>；</li>
<li><strong>析构函数最好定义为虚函数，特别是对于含有继承关系的类</strong>；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ol>
<h4 id="1-4-5-虚函数的实现机制"><a href="#1-4-5-虚函数的实现机制" class="headerlink" title="1.4.5 虚函数的实现机制"></a>1.4.5 虚函数的实现机制</h4><p>实现机制：虚函数通过<strong>虚函数表</strong>来实现。<strong>虚函数的地址保存在虚函数表</strong>中，在类的对象所在的内存空间中，保存了<strong>指向虚函数表的指针</strong>（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表<strong>解决了基类和派生类的继承问题和类中成员函数的覆盖问题</strong>，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<p>虚函数表相关知识点：</p>
<ol>
<li>虚函数表存放的内容：类的虚函数的地址。</li>
<li>虚函数表建立的时间：编译阶段，即程序的<strong>编译过程中会将虚函数的地址放在虚函数表中</strong>。</li>
<li>虚表指针保存的位置：<strong>虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量</strong>。</li>
</ol>
<p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的<strong>不同的对象的虚函数表是一样的</strong>，但是<strong>每个对象都有自己的虚表指针，来指向类的虚函数表</strong>。</p>
<p><strong>★编译器处理虚函数表：</strong></p>
<ol>
<li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li>
<li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li>
<li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中<strong>保存的是重写后的虚函数 B 的地址</strong>，也就是说<strong>虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中</strong>。</li>
<li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li>
</ol>
<h4 id="1-4-6-单继承的虚函数表（无虚函数覆盖）"><a href="#1-4-6-单继承的虚函数表（无虚函数覆盖）" class="headerlink" title="1.4.6 单继承的虚函数表（无虚函数覆盖）"></a>1.4.6 单继承的虚函数表（无虚函数覆盖）</h4><p>基类和派生类的继承关系：</p>
<p><img src="/images/posts/v1.png" alt="v1"></p>
<p>基类的虚函数表：</p>
<p><img src="/images/posts/v2.png" alt="v1"></p>
<p>派生类的虚函数表：</p>
<p><img src="/images/posts/v3.png" alt="v1"></p>
<h4 id="1-4-7-单继承的虚函数表（有虚函数覆盖）"><a href="#1-4-7-单继承的虚函数表（有虚函数覆盖）" class="headerlink" title="1.4.7 单继承的虚函数表（有虚函数覆盖）"></a>1.4.7 单继承的虚函数表（有虚函数覆盖）</h4><p>派生类的虚函数表：</p>
<p><img src="/images/posts/v4.png" alt="v1"></p>
<h4 id="1-4-8-多继承的虚函数表（无虚函数覆盖）"><a href="#1-4-8-多继承的虚函数表（无虚函数覆盖）" class="headerlink" title="1.4.8 多继承的虚函数表（无虚函数覆盖）"></a>1.4.8 多继承的虚函数表（无虚函数覆盖）</h4><p>基类和派生类的继承关系：</p>
<p><img src="/images/posts/v5.png" alt="v1"></p>
<p>派生类的虚函数表：</p>
<p><img src="/images/posts/v6.png" alt="v1"></p>
<h4 id="1-4-9-多继承的虚函数表（有虚函数覆盖）"><a href="#1-4-9-多继承的虚函数表（有虚函数覆盖）" class="headerlink" title="1.4.9 多继承的虚函数表（有虚函数覆盖）"></a>1.4.9 多继承的虚函数表（有虚函数覆盖）</h4><p>基类和派生类的继承关系：</p>
<p><img src="/images/posts/v7.png" alt="v1"></p>
<p>派生类的虚函数表：</p>
<p><img src="/images/posts/v8.png" alt="v1"></p>
<h4 id="1-4-10-构造函数、析构函数是否需要定义成虚函数？为什么？"><a href="#1-4-10-构造函数、析构函数是否需要定义成虚函数？为什么？" class="headerlink" title="1.4.10 构造函数、析构函数是否需要定义成虚函数？为什么？"></a>1.4.10 构造函数、析构函数是否需要定义成虚函数？为什么？</h4><p>构造函数一般不定义为虚函数，原因：</p>
<ol>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li>
<li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li>
<li>从类型上考虑：在创建对象时需要明确其类型。</li>
</ol>
<p>析构函数一般定义成虚函数，原因：<br>析构函数定义成虚函数是为了<strong>防止内存泄漏</strong>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么<strong>只能将基类的成员所占的空间释放掉</strong>，派生类中特有的就会无法释放内存空间导致内存泄漏。</p>
<h4 id="1-4-11-如何避免拷贝？"><a href="#1-4-11-如何避免拷贝？" class="headerlink" title="1.4.11 如何避免拷贝？"></a>1.4.11 如何避免拷贝？</h4><p>最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p>
<p>解决方法：声明一个基类，具体做法如下。</p>
<ol>
<li>定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private</li>
<li>派生类以私有 private 的方式继承基类</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="keyword">const</span> Uncopyable &amp;);            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;); <span class="comment">// 赋值构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">private</span> Uncopyable <span class="comment">// 注意继承方式</span></span><br><span class="line">&#123; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单解释：</p>
<p>能够保证，<strong>在派生类 A 的成员函数和友元函数中无法进行拷贝操作</strong>，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。</p>
<h4 id="1-4-12-为什么用成员初始化列表会快一些？-如何减少构造函数开销？"><a href="#1-4-12-为什么用成员初始化列表会快一些？-如何减少构造函数开销？" class="headerlink" title="1.4.12 为什么用成员初始化列表会快一些？/如何减少构造函数开销？"></a>1.4.12 为什么用成员初始化列表会快一些？/如何减少构造函数开销？</h4><p>说明：数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p>
<p>原因：用户自定义类型如果使用<strong>类初始化列表</strong>，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。**(使用构造函数初始化成员变量：产生临时对象；成员初始化列表：不产生临时对象)**</p>
<h4 id="1-4-13-简述C-的类访问控制"><a href="#1-4-13-简述C-的类访问控制" class="headerlink" title="1.4.13 简述C++的类访问控制"></a>1.4.13 简述C++的类访问控制</h4><p><strong>private, public, protected 访问标号的访问范围</strong>：</p>
<p><strong>private</strong>：只能由1.该类中的函数、2.其友元函数访问。不能被任何其他访问，该类的<strong>对象也不能访问</strong>。</p>
<p><strong>protected</strong>：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。但<strong>不能被该类的对象访问</strong>。</p>
<p><strong>public</strong>：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由 4.<strong>该类的对象访问</strong>。</p>
<p>注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。</p>
<p><strong>类的继承后方法属性变化</strong>：</p>
<p><img src="/images/posts/Visibility-Modes-in-C.jpg" alt="Visibility-Modes-in-C"></p>
<h4 id="1-4-14-多重继承时会出现什么状况？如何解决？"><a href="#1-4-14-多重继承时会出现什么状况？如何解决？" class="headerlink" title="1.4.14 多重继承时会出现什么状况？如何解决？"></a>1.4.14 多重继承时会出现什么状况？如何解决？</h4><p><strong>命名冲突和数据冗余问题。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <span class="comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的继承关系如下：（菱形继承）</p>
<p><img src="/images/posts/v9.png" alt="v9"></p>
<p><strong>上述代码中存的问题：</strong><br>对于派生类 <code>Derive</code> 上述代码中存在直接继承关系和间接继承关系。</p>
<ol>
<li>直接继承：<code>Base2</code> 、<code>Base3</code></li>
<li>间接继承：<code>Base1</code></li>
</ol>
<p>对于派生类中继承的的成员变量 <code>var1</code> ，从继承关系来看，实际上保存了两份，一份是来自基类 <code>Base2</code>，一份来自基类 <code>Base3</code>。因此，出现了<strong>命名冲突</strong>。</p>
<p><strong>解决方法 1：</strong> <strong>声明出现冲突的成员变量来源于哪个类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="comment">// 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法 2：</strong> 虚继承</p>
<p>使用虚继承的目的：<strong>保证存在命名冲突的成员变量在派生类中只保留一份</strong>，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，<strong>直接基类和间接基类之间的继承关系称为虚继承</strong>。</p>
<p>实现方式：<strong>在继承方式前面加上 virtual 关键字</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接基类，即虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 <span class="comment">// 虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 <span class="comment">// 虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类之间的继承关系：</p>
<p><img src="/images/posts/v9.png" alt="v9"></p>
<h4 id="1-4-15-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？"><a href="#1-4-15-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？" class="headerlink" title="1.4.15 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？"></a>1.4.15 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</h4><p><strong>空类声明时编译器不会生成任何成员函数：</strong></p>
<p>对于空类，声明编译器不会生成任何的成员函数，只会生成 <strong>1 个字节的占位符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="comment">// sizeof(A):1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类定义时编译器会生成 6 个成员函数：</p>
<p>当空类 A 定义对象时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class A</span></span><br><span class="line"><span class="comment">&#123;&#125;; 该空类的等价写法如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;                                       <span class="comment">// 缺省构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;tmp)&#123;&#125;;                           <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;                                      <span class="comment">// 析构函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp)&#123;&#125;;                <span class="comment">// 赋值运算符</span></span><br><span class="line">    A *<span class="keyword">operator</span>&amp;() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;;             <span class="comment">// 取址运算符</span></span><br><span class="line">    <span class="keyword">const</span> A *<span class="keyword">operator</span>&amp;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;; <span class="comment">// 取址运算符（const 版本）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="comment">// sizeof(A):1</span></span><br><span class="line">    <span class="keyword">delete</span> p;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-16-为什么拷贝构造函数必须为引用？"><a href="#1-4-16-为什么拷贝构造函数必须为引用？" class="headerlink" title="1.4.16 为什么拷贝构造函数必须为引用？"></a>1.4.16 为什么拷贝构造函数必须为引用？</h4><p>原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">val</span>(tmp) <span class="comment">// 带参数构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;tmp) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp) <span class="comment">// 赋值函数（赋值运算符重载）</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        val = tmp.val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">ex2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    A ex3 = ex1;</span><br><span class="line">    ex2 = ex1;</span><br><span class="line">    ex2.<span class="built_in">fun</span>(ex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">A(int tmp)</span></span><br><span class="line"><span class="comment">A(int tmp)</span></span><br><span class="line"><span class="comment">A(const A &amp;tmp)</span></span><br><span class="line"><span class="comment">A &amp;operator=(const A &amp;tmp)</span></span><br><span class="line"><span class="comment">A(const A &amp;tmp)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明 1：ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？<br>对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值函数；<strong>但是 ex3 还没有实例化，因此调用的是拷贝构造函数，构造出 ex3，而不是赋值函数，这里涉及到构造函数的隐式调用</strong>。</p>
<p>说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 = ex1;会出现什么问题？<br>构造 ex3，实质上是 ex3.A(ex1);，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp)的形参，在参数传递时相当于 A tmp = ex1，因为 tmp 没有被初始化，所以在 A tmp = ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1) ，必然又会有 ex1 作为函数 A(const A tmp); 的形参，在参数传递时相当于即 A tmp = ex1，那么又会触发拷贝构造函数，就这下<strong>永远的递归下去</strong>。</p>
<p>说明 3：为什么 ex2.fun(ex1); 会调用拷贝构造函数？<br><strong>ex1 作为参数传递给 fun 函数， 即 A tmp = ex1;，这个过程会调用拷贝构造函数进行初始化。</strong>(临时对象)</p>
<h4 id="1-4-17-C-类对象的初始化顺序"><a href="#1-4-17-C-类对象的初始化顺序" class="headerlink" title="1.4.17 C++ 类对象的初始化顺序"></a>1.4.17 C++ 类对象的初始化顺序</h4><p>构造函数调用顺序：</p>
<ol>
<li>按照派生类继承基类的顺序，即派生列表中声明的顺序，<strong>依次调用基类的构造函数</strong>；</li>
<li>按照派生类中成员变量的<strong>声名顺序</strong>，依次调用<strong>派生类中成员变量所属类的构造函数</strong>；</li>
<li>执行<strong>派生类自身的构造函数</strong>。</li>
</ol>
<p>综上可以得出，类对象的初始化顺序：<strong>基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数</strong><br>注：</p>
<ol>
<li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关；</li>
<li><strong>成员变量的初始化顺序与声明顺序有关</strong>；</li>
<li><strong>析构顺序和构造顺序相反</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B <span class="comment">// 派生列表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B ex1;</span><br><span class="line">    A ex2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test ex;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">Test()</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">~B()</span></span><br><span class="line"><span class="comment">~B()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序运行结果分析：</p>
<ol>
<li>首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；</li>
<li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li>
<li>最后调用派生类的构造函数；</li>
<li>接下来调用析构函数，和构造函数调用的顺序相反。</li>
</ol>
<h4 id="1-4-18-如何禁止一个类被实例化？"><a href="#1-4-18-如何禁止一个类被实例化？" class="headerlink" title="1.4.18 如何禁止一个类被实例化？"></a>1.4.18 如何禁止一个类被实例化？</h4><p>方法一：</p>
<p>在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；</p>
<p>方法二：</p>
<p>将类的构造函数声明为私有 <code>private</code></p>
<h4 id="1-4-19-实例化一个对象需要哪几个阶段"><a href="#1-4-19-实例化一个对象需要哪几个阶段" class="headerlink" title="1.4.19 实例化一个对象需要哪几个阶段"></a>1.4.19 实例化一个对象需要哪几个阶段</h4><ol>
<li>分配空间<br>创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</li>
<li>初始化<br>首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</li>
<li>赋值<br>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的<strong>初始化是通过初始化列表来完成</strong>，而对象的赋值则才是通过构造函数的函数体来实现。）</li>
</ol>
<p>注：对于拥有虚函数的类的对象，还需要给<strong>虚表指针赋值</strong>。</p>
<ol>
<li><strong>没有继承关系的类，分配完内存后，首先给虚表指针赋值</strong>，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
<li><strong>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值</strong>，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
</ol>
<h4 id="1-4-20-友元函数的作用及使用场景"><a href="#1-4-20-友元函数的作用及使用场景" class="headerlink" title="1.4.20 友元函数的作用及使用场景"></a>1.4.20 友元函数的作用及使用场景</h4><p>作用：友元提供了<strong>不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制</strong>。通过友元，一个不同函数或另一个类中的成员函数可以<strong>访问类中的私有成员和保护成员</strong>。</p>
<p>使用场景：</p>
<ol>
<li><p>普通函数定义为友元函数，<strong>使普通函数能够访问类的私有成员</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="keyword">const</span> A &amp;tmp); <span class="comment">// 声明为类的友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="keyword">const</span> A &amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">    _cout &lt;&lt; tmp.var;</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; ex &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>友元类：类之间共享数据</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">var</span>(<span class="number">10</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl; <span class="comment">// 访问类 A 中的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A ex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(); <span class="comment">// fun():10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-4-21-静态绑定和动态绑定是怎么实现的？"><a href="#1-4-21-静态绑定和动态绑定是怎么实现的？" class="headerlink" title="1.4.21 静态绑定和动态绑定是怎么实现的？"></a>1.4.21 静态绑定和动态绑定是怎么实现的？</h4><p>静态类型和动态类型：</p>
<ol>
<li>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</li>
<li>动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。</li>
</ol>
<p>静态绑定和动态绑定：</p>
<ol>
<li>静态绑定是指程序在 <strong>编译阶段</strong> 确定对象的类型（静态类型）。</li>
<li>动态绑定是指程序在 <strong>运行阶段</strong> 确定对象的类型（动态类型）。</li>
</ol>
<p>静态绑定和动态绑定的区别：</p>
<ol>
<li>发生的时期不同：如上。</li>
<li>对象的静态类型不能更改，动态类型可以更改。</li>
</ol>
<p>注：对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">// p 的静态类型是 Base*，动态类型是 Derive*</span></span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(); <span class="comment">// fun 是虚函数，运行阶段进行动态绑定</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Derive::fun()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-22-深拷贝和浅拷贝的区别"><a href="#1-4-22-深拷贝和浅拷贝的区别" class="headerlink" title="1.4.22 深拷贝和浅拷贝的区别"></a>1.4.22 深拷贝和浅拷贝的区别</h4><p>如果一个类拥有资源，<strong>该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝</strong>。</p>
<ol>
<li>深拷贝：该对象和原对象<strong>占用不同的内存空间</strong>，<strong>既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容</strong>。</li>
<li>浅拷贝：该对象和原对象<strong>占用同一块内存空间</strong>，<strong>仅拷贝类中位于栈空间中的内容</strong>。</li>
</ol>
<p>当类的成员变量中<strong>有指针变量时，最好使用深拷贝</strong>。因为当两个对象指向同一块内存空间，如果使用<strong>浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存</strong>。</p>
<p><strong>浅拷贝实例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">int</span> tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(tmp);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">ex1</span><span class="params">(<span class="number">10</span>)</span></span>;	</span><br><span class="line">	Test ex2 = ex1; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Test(int tmp)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：上述代码中，类对象 ex1、ex2 <strong>实际上是指向同一块内存空间</strong>，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p>
<p><strong>深拷贝实例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">int</span> tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(tmp);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;tmp) <span class="comment">// 定义拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*tmp.p);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">ex1</span><span class="params">(<span class="number">10</span>)</span></span>;	</span><br><span class="line">	Test ex2 = ex1; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Test(int tmp)</span></span><br><span class="line"><span class="comment">Test(const Test &amp;tmp)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-23-编译时多态和运行时多态的区别"><a href="#1-4-23-编译时多态和运行时多态的区别" class="headerlink" title="1.4.23 编译时多态和运行时多态的区别"></a>1.4.23 编译时多态和运行时多态的区别</h4><p>编译时多态：在程序编译过程中出现，发生在<strong>模板和函数重载</strong>中（<strong>泛型编程</strong>）。<br>运行时多态：在程序运行过程中出现，发生在<strong>继承体系中</strong>，是指<strong>通过基类的指针或引用访问派生类中的虚函数</strong>。</p>
<p>编译时多态和运行时多态的区别：</p>
<ol>
<li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li>
<li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。</li>
</ol>
<h4 id="1-4-24-实现一个类成员函数，要求不允许修改类的成员变量？"><a href="#1-4-24-实现一个类成员函数，要求不允许修改类的成员变量？" class="headerlink" title="1.4.24 实现一个类成员函数，要求不允许修改类的成员变量？"></a>1.4.24 实现一个类成员函数，要求不允许修改类的成员变量？</h4><p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 const 关键字来修饰该函数即可。<br>该问题本质是考察 const 关键字修饰成员函数的作用，只不过以实例的方式来考察，面试者应熟练掌握 const 关键字的作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        var1 = <span class="number">10</span>;</span><br><span class="line">        var2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var1 = <span class="number">100</span>; <span class="comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-25-如何让类不能被继承？"><a href="#1-4-25-如何让类不能被继承？" class="headerlink" title="1.4.25 如何让类不能被继承？"></a>1.4.25 如何让类不能被继承？</h4><p>解决方法一：借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span> <span class="keyword">public</span> Base&#123; <span class="comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法二：借助友元、虚继承和私有构造函数来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;B&gt;&#123;   <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;&#125;     <span class="comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：在上述代码中 <code>B</code> 类是不能被继承的类。</p>
<p>具体原因：</p>
<ol>
<li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li>
<li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li>
</ol>
<p>注意：在继承体系中，友元关系不能被继承，虽然 <code>C</code> 类继承了 <code>B</code> 类，<code>B</code> 类是 <code>Base</code> 类的友元，但是 <code>C</code> 类和 <code>Base</code> 类没有友元关系。</p>
<h2 id="2-STL"><a href="#2-STL" class="headerlink" title="2 STL"></a>2 STL</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><h4 id="2-1-1-什么是STL"><a href="#2-1-1-什么是STL" class="headerlink" title="2.1.1 什么是STL"></a>2.1.1 什么是STL</h4><p>标准模板库，增强代码复用性，降低数据结构与算法的耦合关系（容器和算法的分离），提升各自的独立性、弹性和交互性，依据泛型编程的思维架构。</p>
<h4 id="2-1-2-简述STL的六大组件及功能"><a href="#2-1-2-简述STL的六大组件及功能" class="headerlink" title="2.1.2 简述STL的六大组件及功能"></a>2.1.2 简述STL的六大组件及功能</h4><p><img src="/images/posts/STL_work.png" alt="STL_work"></p>
<ol>
<li><strong>空间配置器(allocator)：</strong>负责STL相关数据结构的空间配置与管理。本质是一个实现了动态空间配置、空间管理、空间释放的class template，STL容器、迭代器的模板参数中都含有它。</li>
<li><strong>迭代器(iterator)：</strong>在不暴露容器内部数据结构的情况下，提供遍历容器内元素的方法，是容器和算法的胶合剂，所谓的泛型指针。本质上是一种将operator*、operator-&gt;、operator++、operator–等指针操作重载的class template。所有STL容器都附带专属的迭代器。原生指针是偏特化的迭代器。</li>
<li><strong>容器(container)：</strong>存放数据的数据结构。本质上是一种class template。</li>
<li><strong>算法(algorithm)：</strong>本质是是一种function template。</li>
<li><strong>仿函数/函数对象(functor)：</strong>函数对象，本质上是一种重载了operator()的class或class template。函数指针可视为狭义的仿函数。</li>
<li><strong>配接器(adapter)：</strong>修改已经存在的接口令其展现新的风貌，也是一种设计模式，可以修饰容器、仿函数或迭代器的接口。</li>
</ol>
<h3 id="2-2-空间配置器"><a href="#2-2-空间配置器" class="headerlink" title="2.2 空间配置器"></a>2.2 空间配置器</h3><h4 id="2-2-1-容器如何获取空间配置器"><a href="#2-2-1-容器如何获取空间配置器" class="headerlink" title="2.2.1 容器如何获取空间配置器"></a>2.2.1 容器如何获取空间配置器</h4><p>每一个容器都已经指定其缺省的空间配置器为alloc：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-空间配置器如何进行构造和析构操作"><a href="#2-2-2-空间配置器如何进行构造和析构操作" class="headerlink" title="2.2.2 空间配置器如何进行构造和析构操作"></a>2.2.2 空间配置器如何进行构造和析构操作</h4><p><code>construct()</code>和<code>destroy()</code>被设计为全局函数。</p>
<p><code>construct()</code>接收指针和初值，将初值设定到指针所指的空间上（调用对象的构造函数）。</p>
<p><code>destroy()</code>先萃取迭代器所指对象的型别，判断该对象是否具有trivial-destructor，如果是则什么也不做；否则调用对象的析构函数。</p>
<h4 id="2-2-3-空间配置器的内存配置与释放策略是什么"><a href="#2-2-3-空间配置器的内存配置与释放策略是什么" class="headerlink" title="2.2.3 空间配置器的内存配置与释放策略是什么"></a>2.2.3 空间配置器的内存配置与释放策略是什么</h4><p>采用双层配置器。</p>
<ol>
<li>当配置区块足够大，使用第一级配置器，<code>allocate()</code>直接使用<code>malloc()</code>，<code>deallocate()</code>直接使用<code>free()</code>。</li>
<li>当配置区块太小，为防止内存碎片，使用第二级配置器，维护16个自由链表，负责16种小型区块的次配置能力（类似于Linux伙伴系统算法）。维护内存池来填充自由链表。若内存不足，则调用第一级配置器。</li>
</ol>
<h3 id="2-3-迭代器"><a href="#2-3-迭代器" class="headerlink" title="2.3 迭代器"></a>2.3 迭代器</h3><h4 id="2-3-1-什么是迭代器模式"><a href="#2-3-1-什么是迭代器模式" class="headerlink" title="2.3.1 什么是迭代器模式"></a>2.3.1 什么是迭代器模式</h4><p>提供一种方法，使之能依序巡防某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表达方式。</p>
<h4 id="2-3-2-为什么需要萃取-traits技法-出迭代器的相应型别"><a href="#2-3-2-为什么需要萃取-traits技法-出迭代器的相应型别" class="headerlink" title="2.3.2 为什么需要萃取(traits技法)出迭代器的相应型别"></a>2.3.2 为什么需要萃取(traits技法)出迭代器的相应型别</h4><p>在算法种运用迭代器时，需要用到其相应型别，这样才能在不同情况下提供最大效率。</p>
<p>如：针对随机访问的迭代器和单向访问的迭代器，实现某种算法的步骤可能不同。</p>
<h4 id="2-3-3-迭代器有哪些内嵌的相应型别"><a href="#2-3-3-迭代器有哪些内嵌的相应型别" class="headerlink" title="2.3.3 迭代器有哪些内嵌的相应型别"></a>2.3.3 迭代器有哪些内嵌的相应型别</h4><p>所有迭代器都应该定义下列型别。可以直接继承STL提供的<code>std::iterator</code>。</p>
<ol>
<li>value type：迭代器所指对象的型别<code>T</code></li>
<li>difference type：表示两个迭代器之间的距离。如原生指针之间的距离就可以是整型</li>
<li>reference type：<code>T&amp;</code></li>
<li>pointer type: <code>T*</code></li>
<li>iterator_category：根据移动特性和施行操作，被分为五类<ol>
<li>Input Iter: 只读</li>
<li>Output Iter: 只写</li>
<li>Forward Iter: 单向</li>
<li>Bidirectional Iter: 可双向移动。如某些算法可利用这个特性进行逆向巡防。</li>
<li>Random Access Iter: 随机访问，涵盖所有指针算数能力。</li>
</ol>
</li>
</ol>
<h3 id="2-4-容器"><a href="#2-4-容器" class="headerlink" title="2.4 容器"></a>2.4 容器</h3><p><img src="/images/posts/STL_container.png" alt="STL_container"></p>
<h4 id="2-4-1-STL容器的分类"><a href="#2-4-1-STL容器的分类" class="headerlink" title="2.4.1 STL容器的分类"></a>2.4.1 STL容器的分类</h4><p>序列式：vector, list, deque, stack, queue, heap, priority_queue</p>
<p>关联式：RB-tree, set, multiset, map, multimap, hashtable, hash_set, hash_multiset, hash_map, hash_multimap</p>
<h4 id="2-4-2-vector与array有哪些区别"><a href="#2-4-2-vector与array有哪些区别" class="headerlink" title="2.4.2 vector与array有哪些区别"></a>2.4.2 vector与array有哪些区别</h4><ol>
<li>array是静态空间，一旦配置就不能改变。若需要扩大，需要自己配置新空间，复制元素到新空间，最后释放原空间。</li>
<li>vector是动态空间，使用array实现，内部机制会自行进行空间配置。</li>
</ol>
<h4 id="2-4-3-vector的数据结构"><a href="#2-4-3-vector的数据结构" class="headerlink" title="2.4.3 vector的数据结构"></a>2.4.3 vector的数据结构</h4><p><img src="/images/posts/vector_work.png" alt="vector_work"></p>
<p>线性连续空间，迭代器start和finish分别指向分配的连续空间中目前已被使用的范围，end_of_storage指向包括备用空间在内的整块连续空间的尾端。因此vector的capacity往往大于size。</p>
<p>vector的迭代器其实是原生指针。</p>
<h4 id="2-4-4-简述vector的内存管理策略"><a href="#2-4-4-简述vector的内存管理策略" class="headerlink" title="2.4.4 简述vector的内存管理策略"></a>2.4.4 简述vector的内存管理策略</h4><p>初始化时分配一定空间。</p>
<p>新元素插入尾端时：</p>
<ol>
<li>若还有备用空间，则构造元素，finish++</li>
<li>若没有备用空间，则进行扩容操作：<strong>重新分配（不是原空间）两倍大小的较大空间，将原内容拷贝过来，释放原空间。</strong></li>
</ol>
<p>因此，若空间重新配置，则指向原vector的迭代器会失效。</p>
<h4 id="2-4-5-list的数据结构"><a href="#2-4-5-list的数据结构" class="headerlink" title="2.4.5 list的数据结构"></a>2.4.5 list的数据结构</h4><p>节点结构：</p>
<p><img src="/images/posts/list_node.png" alt="list"></p>
<p>list结构：</p>
<p><img src="/images/posts/list.png" alt="list"></p>
<p>是一个环状双向链表，<code>iter.begin()</code>指向第一个非空节点，<code>iter.end()</code>指向链表尾端的空白节点。</p>
<h4 id="2-4-6-简述deque和vector的区别"><a href="#2-4-6-简述deque和vector的区别" class="headerlink" title="2.4.6 简述deque和vector的区别"></a>2.4.6 简述deque和vector的区别</h4><ol>
<li>vector是单向开口的连续线性空间，deque是双向开口的连续线性空间。</li>
<li>deque允许常数时间内对头端进行插入删除，而vector头部插入删除效率低</li>
<li>deque没有容量的概念，它是动态地以分段连续空间组合而成，因此扩容时不需要 ‘重新配置空间复制再释放’ 这样的操作。</li>
</ol>
<h4 id="2-4-7-简述deque的实现原理"><a href="#2-4-7-简述deque的实现原理" class="headerlink" title="2.4.7 简述deque的实现原理"></a>2.4.7 简述deque的实现原理</h4><p><img src="/images/posts/deque_map.png" alt="deque_map"></p>
<p>deque使用map作为主控。map是一小段连续空间，每个元素node都指向另一段连续线性空间（缓冲区512bytes）。缓冲区是deque的存储主体。</p>
<p><img src="/images/posts/deque_iter.jpg" alt="deque_iter"></p>
<p>start迭代器的cur、first均指向所有缓冲区的第一个元素，last指向第一个缓冲区的末尾。node指向map中的已使用的第一个节点，该节点指向第一个缓冲区。</p>
<p>finish迭代器的cur指向当前deque的最后一个元素，first指向最后一个缓冲区的第一个元素，last指向最后一个缓冲区的末尾，node指向分配最后一个缓冲区的map节点。</p>
<h4 id="2-4-8-如何在deque中随机获取元素"><a href="#2-4-8-如何在deque中随机获取元素" class="headerlink" title="2.4.8 如何在deque中随机获取元素"></a>2.4.8 如何在deque中随机获取元素</h4><p>先计算出元素所在缓冲区，然后计算元素在该缓冲区的偏移量。</p>
<h4 id="2-4-9-简述deque的内存管理策略"><a href="#2-4-9-简述deque的内存管理策略" class="headerlink" title="2.4.9 简述deque的内存管理策略"></a>2.4.9 简述deque的内存管理策略</h4><p>deque使用两个空间配置器，一个用来配置map节点，一个用来配置缓冲区。</p>
<p>初始化时，分配至少8个map节点，为最中央的node分配一段缓冲区作为可用空间。</p>
<p>当元素插入时：</p>
<ol>
<li>被插入的缓冲区有大于1个的可用空间，直接放置元素，更新start或finish</li>
<li>被插入的缓冲区只有1个可用空间，为当前node的前/后一个node分配新的缓冲区，插入元素</li>
<li>若map都已经没有可用空间时，配置更大的map，拷贝原map内容，释放原map</li>
</ol>
<p>当元素删除时：</p>
<p>若导致缓冲区为空，则释放相应缓冲区。但保证至少有1个缓冲区。</p>
<h4 id="2-4-10-简述deque、stack、queue的关系"><a href="#2-4-10-简述deque、stack、queue的关系" class="headerlink" title="2.4.10 简述deque、stack、queue的关系"></a>2.4.10 简述deque、stack、queue的关系</h4><p>deque作为缺省情况下的stack和queue的底部结构，stack、queue是容器配接器，都没有迭代器。</p>
<h4 id="2-4-11-简述heap的实现原理"><a href="#2-4-11-简述heap的实现原理" class="headerlink" title="2.4.11 简述heap的实现原理"></a>2.4.11 简述heap的实现原理</h4><p><img src="/images/posts/implicit_bst.png" alt="implicit_bst"></p>
<p>以vector作为底部结构，一个隐式表述的完全二叉树。元素被取出时总是按照一定的次序。没有迭代器。STL默认供应max-heap。</p>
<p><code>make_heap()</code>：将一段现有的数据转化成一个heap</p>
<p><code>push_heap()</code>：将元素插入到堆中合适的位置（先插入到尾端，然后上溯）</p>
<p><code>pop_heap()</code>：将最大的元素放置到尾端，然后调整堆（令欲调整的节点下溯到最深深度，然后执行一次上溯令其上升到合适位置），此时最后一个元素为最大值，而前面的元素依然是一个max-heap</p>
<p><code>sort_heap()</code>：持续对堆使用<code>pop_heap()</code>最终可以得到升序的序列。</p>
<h3 id="2-4-12-简述priority-queue的实现原理"><a href="#2-4-12-简述priority-queue的实现原理" class="headerlink" title="2.4.12 简述priority_queue的实现原理"></a>2.4.12 简述priority_queue的实现原理</h3><p>内部元素按照权值排列的队列。缺省情况下的priority_queue利用一个max-heap完成，总是弹出键值最大的元素（<code>pop_heap()</code>）。是一个配接器。</p>
<h4 id="2-4-13-什么是关联式容器，有哪几类"><a href="#2-4-13-什么是关联式容器，有哪几类" class="headerlink" title="2.4.13 什么是关联式容器，有哪几类"></a>2.4.13 什么是关联式容器，有哪几类</h4><p>每个元素都有一个**键值(key)**和一个实值(value)，键值可以就是实值。当元素被插入到容器中时，容器内部结构（平衡二叉树或哈希表）按照key的大小以某种特定规则将这个元素放置到合适位置。</p>
<p>分类：set集合和map映射表</p>
<h4 id="2-4-14-简述set的特点及实现原理"><a href="#2-4-14-简述set的特点及实现原理" class="headerlink" title="2.4.14 简述set的特点及实现原理"></a>2.4.14 简述set的特点及实现原理</h4><p>set中元素的键值就是实值，实值就是键值。set中不允许有相同键值, multiset允许。所有元素都会根据键值自动被排序。set的迭代器不能改变元素。（否则会破坏排序）</p>
<p>实现原理：以红黑树作为底层机制，是一种配接器。</p>
<p>具有双向迭代器。</p>
<h4 id="2-4-15-★-简述map的特点及实现原理"><a href="#2-4-15-★-简述map的特点及实现原理" class="headerlink" title="2.4.15 ★ 简述map的特点及实现原理"></a>2.4.15 ★ 简述map的特点及实现原理</h4><p>map的所有元素都是pair，同时拥有键值和实值，第一元素是键值，不允许有相同键值, multimap允许。所有元素都会根据键值自动排序。不可以通过迭代器修改键值，但是可以修改键值对应的实值。</p>
<p>实现原理：以红黑树作为底层机制，是一种配接器。</p>
<p>具有双向迭代器。</p>
<h4 id="2-4-16-简述哈希表的特点"><a href="#2-4-16-简述哈希表的特点" class="headerlink" title="2.4.16 简述哈希表的特点"></a>2.4.16 简述哈希表的特点</h4><p>hashtable（散列表），在插入、删除、搜寻等操作上具有常数平均时间，不需要依赖输入元素的随机性。</p>
<p>利用散列函数，将元素映射到数组的特定位置。</p>
<h4 id="2-4-17-★-什么是碰撞问题，如何解决"><a href="#2-4-17-★-什么是碰撞问题，如何解决" class="headerlink" title="2.4.17 ★ 什么是碰撞问题，如何解决"></a>2.4.17 ★ 什么是碰撞问题，如何解决</h4><p>碰撞问题：使用散列函数时，可能有不同的元素被映射到同一位置，产生冲突。</p>
<p>解决方法：</p>
<ol>
<li>线性探测：若原插入位置不可用，则循序往下一一寻找。primary clustering问题会造成性能下降。</li>
<li>二次探测：不一一寻找，而是在第i次探测时，探测第H+i^2个位置。secondary clustering问题造成性能下降。</li>
<li>开链：在每个表格元素中维护一个list，在list上执行元素操作。list较短时，效率很高。</li>
</ol>
<h4 id="2-4-18-★-简述hashtable的实现原理"><a href="#2-4-18-★-简述hashtable的实现原理" class="headerlink" title="2.4.18 ★ 简述hashtable的实现原理"></a>2.4.18 ★ 简述hashtable的实现原理</h4><p>以开链法实现hashtable：</p>
<p><img src="/images/posts/hashtable_work.png" alt="hashtable_work"></p>
<p>图中buckets结构指向链表头，链表中存放hashtable的元素。buckets聚合体以vector作为底层机制，利于动态扩充。</p>
<p>具有单向迭代器。</p>
<h4 id="2-4-19-简述hashtable的内存管理策略"><a href="#2-4-19-简述hashtable的内存管理策略" class="headerlink" title="2.4.19 简述hashtable的内存管理策略"></a>2.4.19 简述hashtable的内存管理策略</h4><p>hashtable预定义了一组素数，初始化时选择最近的那个素数作为表格大小。</p>
<p>插入元素时：</p>
<ol>
<li>若插入后元素个数不大于表格大小，则计算出索引后直接插入到链表中。若检测到重复键值，则不插入。</li>
<li>否则，需要重建表格（说明hashtable元素最大个数与表格大小相同），执行重新分配，复制，释放操作。</li>
</ol>
<h4 id="2-4-20-hashtable的键值可以任意取吗"><a href="#2-4-20-hashtable的键值可以任意取吗" class="headerlink" title="2.4.20 hashtable的键值可以任意取吗"></a>2.4.20 hashtable的键值可以任意取吗</h4><p>下列类型：char*, short, int, long，可以直接被处理。如果是其它类型，需要用户自定义散列函数，如string。</p>
<h4 id="2-4-21-简述hash-set-unordered-set-的特点及实现原理"><a href="#2-4-21-简述hash-set-unordered-set-的特点及实现原理" class="headerlink" title="2.4.21 简述hash_set(unordered_set)的特点及实现原理"></a>2.4.21 简述hash_set(unordered_set)的特点及实现原理</h4><p>hash_set中的元素与set类似，但没有自动排序功能，支持快速查找元素，hash_multiset支持重复键值。</p>
<p>实现原理：以hashtable作为底层机制。</p>
<h4 id="2-4-22-★-简述hash-map-unordered-map-的特点及实现原理"><a href="#2-4-22-★-简述hash-map-unordered-map-的特点及实现原理" class="headerlink" title="2.4.22 ★ 简述hash_map(unordered_map)的特点及实现原理"></a>2.4.22 ★ 简述hash_map(unordered_map)的特点及实现原理</h4><p>hash_map中的元素与map类似，但没有自动排序功能，支持快速查找元素，hash_multimap支持重复键值。</p>
<p>实现原理：以hashtable作为底层机制。</p>
<h4 id="2-4-23-对比STL的各种容器"><a href="#2-4-23-对比STL的各种容器" class="headerlink" title="2.4.23 对比STL的各种容器"></a>2.4.23 对比STL的各种容器</h4><p><img src="/images/posts/stl_complexity.png" alt="stl_complexity"></p>
<h3 id="2-5-算法"><a href="#2-5-算法" class="headerlink" title="2.5 算法"></a>2.5 算法</h3><h4 id="2-5-1-简述什么是算法的泛型化"><a href="#2-5-1-简述什么是算法的泛型化" class="headerlink" title="2.5.1 简述什么是算法的泛型化"></a>2.5.1 简述什么是算法的泛型化</h4><p>将算法独立于其处理的数据结构：把操作对象的型别抽象化，把操作对象的表示法和区间目标的移动行为抽象化。</p>
<p>迭代器便充当了此处的操作对象，它把数据结构和算法连接在一起。</p>
<h4 id="2-5-2-简述sort-算法的实现原理"><a href="#2-5-2-简述sort-算法的实现原理" class="headerlink" title="2.5.2 简述sort()算法的实现原理"></a>2.5.2 简述sort()算法的实现原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>接收两个随机存取迭代器（vector和deque），将区间内的元素按仿函数comp定义的规则排序。</p>
<p>数据量很大时，采用快速排序（分段递归）。数据量较小时，采用插入排序</p>
<h3 id="2-6-仿函数"><a href="#2-6-仿函数" class="headerlink" title="2.6 仿函数"></a>2.6 仿函数</h3><h4 id="2-6-1-什么是仿函数，有什么作用"><a href="#2-6-1-什么是仿函数，有什么作用" class="headerlink" title="2.6.1 什么是仿函数，有什么作用"></a>2.6.1 什么是仿函数，有什么作用</h4><p>新名称：函数对象，可以像函数一样被调用。</p>
<p>作用：主要用于搭配STL算法使用，将某种操作（加减、比大小等）作为一个参数传递给算法，类似于函数指针。</p>
<p>为什么不直接使用函数指针？函数指针不能满足STL对抽象性的要求，也无法与STL其它组件搭配，产生更灵活的变化。</p>
<h4 id="2-6-2-如何定义一个仿函数"><a href="#2-6-2-如何定义一个仿函数" class="headerlink" title="2.6.2 如何定义一个仿函数"></a>2.6.2 如何定义一个仿函数</h4><p>定义一个对象，然后重载函数调用运算符operator()。</p>
<h4 id="2-6-3-有哪些常见的仿函数"><a href="#2-6-3-有哪些常见的仿函数" class="headerlink" title="2.6.3 有哪些常见的仿函数"></a>2.6.3 有哪些常见的仿函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算术类</span></span><br><span class="line">plus&lt;T&gt;;</span><br><span class="line">minus&lt;T&gt;;</span><br><span class="line">multiplies&lt;T&gt;;</span><br><span class="line">divides&lt;T&gt;;</span><br><span class="line">modulus&lt;T&gt;;</span><br><span class="line">negate&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算类</span></span><br><span class="line">equal_to&lt;T&gt;;</span><br><span class="line">not_equal_to&lt;T&gt;;</span><br><span class="line">greater&lt;T&gt;;</span><br><span class="line">greater_equal&lt;T&gt;;</span><br><span class="line">less&lt;T&gt;;</span><br><span class="line">less_equal&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑类</span></span><br><span class="line">logical_and&lt;T&gt;;</span><br><span class="line">logical_or&lt;T&gt;;</span><br><span class="line">logical_not&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-配接器"><a href="#2-7-配接器" class="headerlink" title="2.7 配接器"></a>2.7 配接器</h3><p>（未整理完~）</p>
<h2 id="3-对象模型"><a href="#3-对象模型" class="headerlink" title="3 对象模型"></a>3 对象模型</h2><p>（未整理完~）</p>
<h2 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4 设计模式"></a>4 设计模式</h2><h3 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h3><h4 id="4-1-1-有哪些设计模式"><a href="#4-1-1-有哪些设计模式" class="headerlink" title="4.1.1 有哪些设计模式"></a>4.1.1 有哪些设计模式</h4><p>设计模式分为三类：</p>
<ol>
<li>创造型模式：<strong>单例模式</strong>、<strong>工厂模式</strong>、建造者模式、原型模式</li>
<li>结构型模式：<strong>适配器模式</strong>、<strong>组合模式</strong>、<strong>装饰模式</strong>、桥接模式、外观模式、享元模式、代理模式</li>
<li>行为型模式：<strong>迭代器模式</strong>、<strong>观察者模式</strong>、<strong>策略模式</strong>、责任链模式、命令模式、解释器模式、中介者模式、备忘录模式、状态模式、模板方法模式、访问者模式</li>
</ol>
<h4 id="4-1-2-设计模式的设计原则"><a href="#4-1-2-设计模式的设计原则" class="headerlink" title="4.1.2 设计模式的设计原则"></a>4.1.2 设计模式的设计原则</h4><p>设计模式有 6 大设计原则：</p>
<ol>
<li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。</li>
<li>开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li>
<li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li>
<li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。</li>
<li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li>
<li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li>
</ol>
<h3 id="4-2-单例模式"><a href="#4-2-单例模式" class="headerlink" title="4.2 单例模式"></a>4.2 单例模式</h3><h4 id="4-2-1-什么是单例模式，什么时候应用"><a href="#4-2-1-什么是单例模式，什么时候应用" class="headerlink" title="4.2.1 什么是单例模式，什么时候应用"></a>4.2.1 什么是单例模式，什么时候应用</h4><p>保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。</p>
<p>应用场景：</p>
<ol>
<li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li>
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li>
</ol>
<h4 id="4-2-2-实现思路"><a href="#4-2-2-实现思路" class="headerlink" title="4.2.2 实现思路"></a>4.2.2 实现思路</h4><p>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</p>
<ol>
<li>默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的，这样禁止在类的外部创建该对象；</li>
<li>全局访问点也要定义成 静态类型的成员函数，没有参数，<strong>返回该类的指针类型</strong>。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li>
</ol>
<h4 id="4-2-3-不安全的实现方式（懒汉）"><a href="#4-2-3-不安全的实现方式（懒汉）" class="headerlink" title="4.2.3 不安全的实现方式（懒汉）"></a>4.2.3 不安全的实现方式（懒汉）</h4><p>考虑当两个线程同时调用 <code>getInstance</code> 方法，并且同时检测到 <code>instance</code> 是 <code>NULL</code>，两个线程会同时实例化对象，不符合单例模式的要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-线程安全的实现方式（懒汉）"><a href="#4-2-4-线程安全的实现方式（懒汉）" class="headerlink" title="4.2.4 线程安全的实现方式（懒汉）"></a>4.2.4 线程安全的实现方式（懒汉）</h4><p>方法：<strong>加锁</strong><br>存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;            </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Singleton::mutex;</span><br></pre></td></tr></table></figure>

<p>方法：<strong>内部静态变量</strong>，在全局访问点 <code>getInstance</code> 中定义静态实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123; </span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Singleton::mutex; </span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-饿汉模式实现（本身即线程安全）"><a href="#4-2-5-饿汉模式实现（本身即线程安全）" class="headerlink" title="4.2.5 饿汉模式实现（本身即线程安全）"></a>4.2.5 饿汉模式实现（本身即线程安全）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式：类定义的时候就实例化。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	 <span class="built_in">Singleton</span>()&#123;&#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123; </span><br><span class="line">        <span class="keyword">return</span> instance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure>

<h3 id="4-3-工厂模式"><a href="#4-3-工厂模式" class="headerlink" title="4.3 工厂模式"></a>4.3 工厂模式</h3><p>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式</p>
<ol>
<li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li>
<li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li>
<li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li>
</ol>
<h4 id="4-3-1-什么是简单工厂模式，什么时候应用"><a href="#4-3-1-什么是简单工厂模式，什么时候应用" class="headerlink" title="4.3.1 什么是简单工厂模式，什么时候应用"></a>4.3.1 什么是简单工厂模式，什么时候应用</h4><p>主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</p>
<p><strong>应用场景</strong>：</p>
<p>适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如：计算器中对于同样的输入，执行不同的操作：加、减、乘、除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Operation *<span class="title">CreateProduct</span><span class="params">(<span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Operation *p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-什么是工厂方法模式，什么时候应用"><a href="#4-3-2-什么是工厂方法模式，什么时候应用" class="headerlink" title="4.3.2 什么是工厂方法模式，什么时候应用"></a>4.3.2 什么是工厂方法模式，什么时候应用</h4><p>修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p>
<p>应用场景：</p>
<ol>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其派生类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，派生类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务<strong>委托给多个工厂派生类中的某一个</strong>，客户端在使用时可以无须关心是哪一个工厂派生类创建产品派生类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Operation</span> :</span> <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation *p_pro = p_fac-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Mul_Factory *p_fac1 = <span class="keyword">new</span> <span class="built_in">Mul_Factory</span>();</span><br><span class="line">    Operation *p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-什么是抽象工厂模式，什么时候应用"><a href="#4-3-3-什么是抽象工厂模式，什么时候应用" class="headerlink" title="4.3.3 什么是抽象工厂模式，什么时候应用"></a>4.3.3 什么是抽象工厂模式，什么时候应用</h4><p>定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p>
<p>应用场景：</p>
<ol>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的<strong>产品族</strong>，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation_Pos</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Operation_Pos</span> :</span> <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Operation_Pos</span> :</span> <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Operation_Pos</span> :</span> <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Operation_Pos</span> :</span> <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation_Neg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Operation_Neg</span> :</span> <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 + var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Operation_Neg</span> :</span> <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 - var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Operation_Neg</span> :</span> <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 * var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Operation_Neg</span> :</span> <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 / var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Factory</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation_Pos *p_pro = p_fac-&gt;<span class="built_in">CreateProduct_Pos</span>();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Add_Factory *p_fac1 = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation_Neg *p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct_Neg</span>();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-观察者模式"><a href="#4-4-观察者模式" class="headerlink" title="4.4 观察者模式"></a>4.4 观察者模式</h3><h4 id="4-4-1-什么是观察者模式，什么时候应用"><a href="#4-4-1-什么是观察者模式，什么时候应用" class="headerlink" title="4.4.1 什么是观察者模式，什么时候应用"></a>4.4.1 什么是观察者模式，什么时候应用</h4><p>观察者模式：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p>
<p>观察者模式中存在两种角色：</p>
<ol>
<li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li>
<li>被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li>
</ol>
<p>应用场景：</p>
<ol>
<li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li>
<li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li>
</ol>
<h4 id="4-4-2-观察者模式的实现方式"><a href="#4-4-2-观察者模式的实现方式" class="headerlink" title="4.4.2 观察者模式的实现方式"></a>4.4.2 观察者模式的实现方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>;</span></span><br><span class="line"><span class="comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Subject *sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Observer</span>(string name, Subject *sub)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sub = sub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockObserver</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBAObserver</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NBAObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;Observer *&gt; observers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string action; <span class="comment">//被观察者对象的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretary</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*iter) == observer)</span><br><span class="line">            &#123;</span><br><span class="line">                observers.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StockObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NBAObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject *dwq = <span class="keyword">new</span> <span class="built_in">Secretary</span>();</span><br><span class="line">    Observer *xs = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;xiaoshuai&quot;</span>, dwq);</span><br><span class="line">    Observer *zy = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;zouyue&quot;</span>, dwq);</span><br><span class="line">    Observer *lm = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;limin&quot;</span>, dwq);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(xs);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(zy);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(lm);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;去吃饭了！&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;梁所长来了!&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>（未整理完~）</p>
<p>Reference:</p>
<ol>
<li>《C++ Primer Plus》</li>
<li>《深度探索C++对象模型》- Stanley B. Lippman</li>
<li>《STL源码解析》 - 侯捷</li>
<li> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/cpp-interview-highlights/">C++突击</a></li>
</ol>
</div><hr style="height:1px;margin:1rem 0"></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/26/2021-04-26-interview-internet-protocols/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">面试-计算机网络与网络编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/24/2021-04-25-interview-overview/"><span class="level-item">面试-2021微信暑期实习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Felix Feng"></figure><p class="title is-size-4 is-block" style="font-weight: bold">Felix Feng</p><p class="is-size-6 is-block" style="margin-top: 1rem">jsjhfx@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Posts</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Tags</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/2horse9sun" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/2horse9sun"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="is-4-tablet is-4-desktop is-3-widescreen  is-sticky" style="margin-top: 1.5rem"> <div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-C-基础"><span class="level-left"><span class="level-item">1 C++基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-语言特性"><span class="level-left"><span class="level-item">1.1 语言特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-C-11有哪些新特性"><span class="level-left"><span class="level-item">1.1.1 C++11有哪些新特性</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-C-和-C-的区别"><span class="level-left"><span class="level-item">1.1.2 C 和 C++ 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-3-Java-和-C-的区别"><span class="level-left"><span class="level-item">1.1.3 Java 和 C++ 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-4-Python-和-C-的区别"><span class="level-left"><span class="level-item">1.1.4 Python 和 C++ 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-5-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"><span class="level-left"><span class="level-item">1.1.5 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</span></span></a></li><li><a class="level is-mobile" href="#1-1-6-std-move-函数的实现原理"><span class="level-left"><span class="level-item">1.1.6 std::move() 函数的实现原理</span></span></a></li><li><a class="level is-mobile" href="#1-1-7-什么是指针？指针的大小及用法？"><span class="level-left"><span class="level-item">1.1.7 什么是指针？指针的大小及用法？</span></span></a></li><li><a class="level is-mobile" href="#1-1-8-什么是野指针和悬空指针？"><span class="level-left"><span class="level-item">1.1.8 什么是野指针和悬空指针？</span></span></a></li><li><a class="level is-mobile" href="#1-1-9-C-11-nullptr-比-NULL-优势"><span class="level-left"><span class="level-item">1.1.9 C++ 11 nullptr 比 NULL 优势</span></span></a></li><li><a class="level is-mobile" href="#1-1-10-指针和引用的区别？"><span class="level-left"><span class="level-item">1.1.10 指针和引用的区别？</span></span></a></li><li><a class="level is-mobile" href="#1-1-11-常量指针和指针常量的区别"><span class="level-left"><span class="level-item">1.1.11 常量指针和指针常量的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-12-函数指针和指针函数的区别"><span class="level-left"><span class="level-item">1.1.12 函数指针和指针函数的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-13-强制类型转换有哪几种？"><span class="level-left"><span class="level-item">1.1.13 强制类型转换有哪几种？</span></span></a></li><li><a class="level is-mobile" href="#1-1-14-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？"><span class="level-left"><span class="level-item">1.1.14 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</span></span></a></li><li><a class="level is-mobile" href="#1-1-15-参数传递时，值传递、引用传递、指针传递的区别？"><span class="level-left"><span class="level-item">1.1.15 参数传递时，值传递、引用传递、指针传递的区别？</span></span></a></li><li><a class="level is-mobile" href="#1-1-16-什么是模板？如何实现？"><span class="level-left"><span class="level-item">1.1.16 什么是模板？如何实现？</span></span></a></li><li><a class="level is-mobile" href="#1-1-17-函数模板和类模板的区别？"><span class="level-left"><span class="level-item">1.1.17 函数模板和类模板的区别？</span></span></a></li><li><a class="level is-mobile" href="#1-1-18-什么是可变参数模板？"><span class="level-left"><span class="level-item">1.1.18 什么是可变参数模板？</span></span></a></li><li><a class="level is-mobile" href="#1-1-19-什么是模板特化？为什么特化？"><span class="level-left"><span class="level-item">1.1.19 什么是模板特化？为什么特化？</span></span></a></li><li><a class="level is-mobile" href="#1-1-20-include-“-“-和-lt-gt-的区别"><span class="level-left"><span class="level-item">1.1.20 include “ “ 和 &lt;&gt; 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-21-switch-的-case-里为何不能定义变量"><span class="level-left"><span class="level-item">1.1.21 switch 的 case 里为何不能定义变量</span></span></a></li><li><a class="level is-mobile" href="#1-1-22-迭代器的作用？"><span class="level-left"><span class="level-item">1.1.22 迭代器的作用？</span></span></a></li><li><a class="level is-mobile" href="#1-1-23-泛型编程如何实现？"><span class="level-left"><span class="level-item">1.1.23 泛型编程如何实现？</span></span></a></li><li><a class="level is-mobile" href="#1-1-24-什么是类型萃取？"><span class="level-left"><span class="level-item">1.1.24 什么是类型萃取？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-编译与内存"><span class="level-left"><span class="level-item">1.2 编译与内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-1-C-程序编译过程"><span class="level-left"><span class="level-item">1.2.1 C++ 程序编译过程</span></span></a></li><li><a class="level is-mobile" href="#1-2-2-C-内存管理"><span class="level-left"><span class="level-item">1.2.2 C++ 内存管理</span></span></a></li><li><a class="level is-mobile" href="#1-2-3-栈和堆的区别"><span class="level-left"><span class="level-item">1.2.3 栈和堆的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-4-全局变量、局部变量、静态全局变量、静态局部变量的区别"><span class="level-left"><span class="level-item">1.2.4 全局变量、局部变量、静态全局变量、静态局部变量的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-5-全局变量定义在头文件中有什么问题？"><span class="level-left"><span class="level-item">1.2.5 全局变量定义在头文件中有什么问题？</span></span></a></li><li><a class="level is-mobile" href="#1-2-6-如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"><span class="level-left"><span class="level-item">1.2.6 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</span></span></a></li><li><a class="level is-mobile" href="#1-2-7-什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？"><span class="level-left"><span class="level-item">1.2.7 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</span></span></a></li><li><a class="level is-mobile" href="#1-2-8-类大小的计算"><span class="level-left"><span class="level-item">1.2.8 类大小的计算</span></span></a></li><li><a class="level is-mobile" href="#1-2-9-什么是内存泄露"><span class="level-left"><span class="level-item">1.2.9 什么是内存泄露</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-10-怎么防止内存泄漏？内存泄漏检测工具的原理？"><span class="level-left"><span class="level-item">1.2.10 怎么防止内存泄漏？内存泄漏检测工具的原理？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-11-智能指针有哪几种？智能指针的实现原理？"><span class="level-left"><span class="level-item">1.2.11 智能指针有哪几种？智能指针的实现原理？</span></span></a></li><li><a class="level is-mobile" href="#1-2-12-使用智能指针会出现什么问题？怎么解决？"><span class="level-left"><span class="level-item">1.2.12 使用智能指针会出现什么问题？怎么解决？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-关键字与库函数"><span class="level-left"><span class="level-item">1.3 关键字与库函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-1-sizeof-和-strlen-的区别"><span class="level-left"><span class="level-item">1.3.1 sizeof 和 strlen 的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-2-lambda-表达式（匿名函数）的具体应用和使用场景"><span class="level-left"><span class="level-item">1.3.2 lambda 表达式（匿名函数）的具体应用和使用场景</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-3-explicit-的作用（如何避免编译器进行隐式类型转换）"><span class="level-left"><span class="level-item">1.3.3 explicit 的作用（如何避免编译器进行隐式类型转换）</span></span></a></li><li><a class="level is-mobile" href="#1-3-4-static-的作用"><span class="level-left"><span class="level-item">1.3.4 static 的作用</span></span></a></li><li><a class="level is-mobile" href="#1-3-5-★-static-在类中使用的注意事项（定义、初始化和使用）"><span class="level-left"><span class="level-item">1.3.5 ★ static 在类中使用的注意事项（定义、初始化和使用）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-6-static-全局变量和普通全局变量的异同"><span class="level-left"><span class="level-item">1.3.6 static 全局变量和普通全局变量的异同</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-7-★-const-作用及用法"><span class="level-left"><span class="level-item">1.3.7 ★ const 作用及用法</span></span></a></li><li><a class="level is-mobile" href="#1-3-8-define-和-const-的区别"><span class="level-left"><span class="level-item">1.3.8 define 和 const 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-9-define-和-typedef-的区别"><span class="level-left"><span class="level-item">1.3.9 define 和 typedef 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-10-用宏实现比较大小，以及两个数中的最小值"><span class="level-left"><span class="level-item">1.3.10 用宏实现比较大小，以及两个数中的最小值</span></span></a></li><li><a class="level is-mobile" href="#1-3-11-inline-作用、使用方法和原理"><span class="level-left"><span class="level-item">1.3.11 inline 作用、使用方法和原理</span></span></a></li><li><a class="level is-mobile" href="#1-3-12-宏定义（define）和内联函数（inline）的区别"><span class="level-left"><span class="level-item">1.3.12  宏定义（define）和内联函数（inline）的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-13-new-和-malloc-如何判断是否申请到内存？"><span class="level-left"><span class="level-item">1.3.13 new 和 malloc 如何判断是否申请到内存？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-14-delete-实现原理？delete-和-delete-的区别？"><span class="level-left"><span class="level-item">1.3.14 delete 实现原理？delete 和 delete[] 的区别？</span></span></a></li><li><a class="level is-mobile" href="#1-3-15-new-和-malloc-的区别，delete-和-free-的区别"><span class="level-left"><span class="level-item">1.3.15 new 和 malloc 的区别，delete 和 free 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-16-malloc-的原理？malloc-的底层实现？"><span class="level-left"><span class="level-item">1.3.16 malloc 的原理？malloc 的底层实现？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-17-C-和-C-struct-的区别？"><span class="level-left"><span class="level-item">1.3.17 C 和 C++ struct 的区别？</span></span></a></li><li><a class="level is-mobile" href="#1-3-18-struct-和-union-的区别"><span class="level-left"><span class="level-item">1.3.18 struct 和 union 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-19-class-和-struct-的异同"><span class="level-left"><span class="level-item">1.3.19 class 和 struct 的异同</span></span></a></li><li><a class="level is-mobile" href="#1-3-20-volatile-的作用？是否具有原子性，对编译器有什么影响？"><span class="level-left"><span class="level-item">1.3.20 volatile 的作用？是否具有原子性，对编译器有什么影响？</span></span></a></li><li><a class="level is-mobile" href="#1-3-21-什么情况下一定要用-volatile，-能否和-const-一起使用？"><span class="level-left"><span class="level-item">1.3.21 什么情况下一定要用 volatile， 能否和 const 一起使用？</span></span></a></li><li><a class="level is-mobile" href="#1-3-22-extern-C-的作用？"><span class="level-left"><span class="level-item">1.3.22 extern C 的作用？</span></span></a></li><li><a class="level is-mobile" href="#1-3-23-sizeof-1-1-在-C-和-C-中分别是什么结果？"><span class="level-left"><span class="level-item">1.3.23 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？</span></span></a></li><li><a class="level is-mobile" href="#1-3-24-★-memcpy和memmove-函数的底层原理？"><span class="level-left"><span class="level-item">1.3.24 ★ memcpy和memmove 函数的底层原理？</span></span></a></li><li><a class="level is-mobile" href="#1-3-25-strcpy-函数有什么缺陷？"><span class="level-left"><span class="level-item">1.3.25 strcpy 函数有什么缺陷？</span></span></a></li><li><a class="level is-mobile" href="#1-3-26-auto-类型推导的原理"><span class="level-left"><span class="level-item">1.3.26 auto 类型推导的原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-4-面向对象"><span class="level-left"><span class="level-item">1.4 面向对象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-4-1-什么是面向对象？面向对象的三大特性"><span class="level-left"><span class="level-item">1.4.1 什么是面向对象？面向对象的三大特性</span></span></a></li><li><a class="level is-mobile" href="#1-4-2-重载、重写、隐藏的区别"><span class="level-left"><span class="level-item">1.4.2 重载、重写、隐藏的区别</span></span></a></li><li><a class="level is-mobile" href="#1-4-3-什么是多态？多态如何实现？"><span class="level-left"><span class="level-item">1.4.3 什么是多态？多态如何实现？</span></span></a></li><li><a class="level is-mobile" href="#1-4-4-什么是虚函数？什么是纯虚函数？两者有何区别"><span class="level-left"><span class="level-item">1.4.4 什么是虚函数？什么是纯虚函数？两者有何区别</span></span></a></li><li><a class="level is-mobile" href="#1-4-5-虚函数的实现机制"><span class="level-left"><span class="level-item">1.4.5 虚函数的实现机制</span></span></a></li><li><a class="level is-mobile" href="#1-4-6-单继承的虚函数表（无虚函数覆盖）"><span class="level-left"><span class="level-item">1.4.6 单继承的虚函数表（无虚函数覆盖）</span></span></a></li><li><a class="level is-mobile" href="#1-4-7-单继承的虚函数表（有虚函数覆盖）"><span class="level-left"><span class="level-item">1.4.7 单继承的虚函数表（有虚函数覆盖）</span></span></a></li><li><a class="level is-mobile" href="#1-4-8-多继承的虚函数表（无虚函数覆盖）"><span class="level-left"><span class="level-item">1.4.8 多继承的虚函数表（无虚函数覆盖）</span></span></a></li><li><a class="level is-mobile" href="#1-4-9-多继承的虚函数表（有虚函数覆盖）"><span class="level-left"><span class="level-item">1.4.9 多继承的虚函数表（有虚函数覆盖）</span></span></a></li><li><a class="level is-mobile" href="#1-4-10-构造函数、析构函数是否需要定义成虚函数？为什么？"><span class="level-left"><span class="level-item">1.4.10 构造函数、析构函数是否需要定义成虚函数？为什么？</span></span></a></li><li><a class="level is-mobile" href="#1-4-11-如何避免拷贝？"><span class="level-left"><span class="level-item">1.4.11 如何避免拷贝？</span></span></a></li><li><a class="level is-mobile" href="#1-4-12-为什么用成员初始化列表会快一些？-如何减少构造函数开销？"><span class="level-left"><span class="level-item">1.4.12 为什么用成员初始化列表会快一些？/如何减少构造函数开销？</span></span></a></li><li><a class="level is-mobile" href="#1-4-13-简述C-的类访问控制"><span class="level-left"><span class="level-item">1.4.13 简述C++的类访问控制</span></span></a></li><li><a class="level is-mobile" href="#1-4-14-多重继承时会出现什么状况？如何解决？"><span class="level-left"><span class="level-item">1.4.14 多重继承时会出现什么状况？如何解决？</span></span></a></li><li><a class="level is-mobile" href="#1-4-15-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？"><span class="level-left"><span class="level-item">1.4.15 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</span></span></a></li><li><a class="level is-mobile" href="#1-4-16-为什么拷贝构造函数必须为引用？"><span class="level-left"><span class="level-item">1.4.16 为什么拷贝构造函数必须为引用？</span></span></a></li><li><a class="level is-mobile" href="#1-4-17-C-类对象的初始化顺序"><span class="level-left"><span class="level-item">1.4.17 C++ 类对象的初始化顺序</span></span></a></li><li><a class="level is-mobile" href="#1-4-18-如何禁止一个类被实例化？"><span class="level-left"><span class="level-item">1.4.18 如何禁止一个类被实例化？</span></span></a></li><li><a class="level is-mobile" href="#1-4-19-实例化一个对象需要哪几个阶段"><span class="level-left"><span class="level-item">1.4.19 实例化一个对象需要哪几个阶段</span></span></a></li><li><a class="level is-mobile" href="#1-4-20-友元函数的作用及使用场景"><span class="level-left"><span class="level-item">1.4.20 友元函数的作用及使用场景</span></span></a></li><li><a class="level is-mobile" href="#1-4-21-静态绑定和动态绑定是怎么实现的？"><span class="level-left"><span class="level-item">1.4.21 静态绑定和动态绑定是怎么实现的？</span></span></a></li><li><a class="level is-mobile" href="#1-4-22-深拷贝和浅拷贝的区别"><span class="level-left"><span class="level-item">1.4.22 深拷贝和浅拷贝的区别</span></span></a></li><li><a class="level is-mobile" href="#1-4-23-编译时多态和运行时多态的区别"><span class="level-left"><span class="level-item">1.4.23 编译时多态和运行时多态的区别</span></span></a></li><li><a class="level is-mobile" href="#1-4-24-实现一个类成员函数，要求不允许修改类的成员变量？"><span class="level-left"><span class="level-item">1.4.24 实现一个类成员函数，要求不允许修改类的成员变量？</span></span></a></li><li><a class="level is-mobile" href="#1-4-25-如何让类不能被继承？"><span class="level-left"><span class="level-item">1.4.25 如何让类不能被继承？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#2-STL"><span class="level-left"><span class="level-item">2 STL</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-基础"><span class="level-left"><span class="level-item">2.1 基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-什么是STL"><span class="level-left"><span class="level-item">2.1.1 什么是STL</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-简述STL的六大组件及功能"><span class="level-left"><span class="level-item">2.1.2 简述STL的六大组件及功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-空间配置器"><span class="level-left"><span class="level-item">2.2 空间配置器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-容器如何获取空间配置器"><span class="level-left"><span class="level-item">2.2.1 容器如何获取空间配置器</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-空间配置器如何进行构造和析构操作"><span class="level-left"><span class="level-item">2.2.2 空间配置器如何进行构造和析构操作</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-空间配置器的内存配置与释放策略是什么"><span class="level-left"><span class="level-item">2.2.3 空间配置器的内存配置与释放策略是什么</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-迭代器"><span class="level-left"><span class="level-item">2.3 迭代器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-1-什么是迭代器模式"><span class="level-left"><span class="level-item">2.3.1 什么是迭代器模式</span></span></a></li><li><a class="level is-mobile" href="#2-3-2-为什么需要萃取-traits技法-出迭代器的相应型别"><span class="level-left"><span class="level-item">2.3.2 为什么需要萃取(traits技法)出迭代器的相应型别</span></span></a></li><li><a class="level is-mobile" href="#2-3-3-迭代器有哪些内嵌的相应型别"><span class="level-left"><span class="level-item">2.3.3 迭代器有哪些内嵌的相应型别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-4-容器"><span class="level-left"><span class="level-item">2.4 容器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-4-1-STL容器的分类"><span class="level-left"><span class="level-item">2.4.1 STL容器的分类</span></span></a></li><li><a class="level is-mobile" href="#2-4-2-vector与array有哪些区别"><span class="level-left"><span class="level-item">2.4.2 vector与array有哪些区别</span></span></a></li><li><a class="level is-mobile" href="#2-4-3-vector的数据结构"><span class="level-left"><span class="level-item">2.4.3 vector的数据结构</span></span></a></li><li><a class="level is-mobile" href="#2-4-4-简述vector的内存管理策略"><span class="level-left"><span class="level-item">2.4.4 简述vector的内存管理策略</span></span></a></li><li><a class="level is-mobile" href="#2-4-5-list的数据结构"><span class="level-left"><span class="level-item">2.4.5 list的数据结构</span></span></a></li><li><a class="level is-mobile" href="#2-4-6-简述deque和vector的区别"><span class="level-left"><span class="level-item">2.4.6 简述deque和vector的区别</span></span></a></li><li><a class="level is-mobile" href="#2-4-7-简述deque的实现原理"><span class="level-left"><span class="level-item">2.4.7 简述deque的实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-8-如何在deque中随机获取元素"><span class="level-left"><span class="level-item">2.4.8 如何在deque中随机获取元素</span></span></a></li><li><a class="level is-mobile" href="#2-4-9-简述deque的内存管理策略"><span class="level-left"><span class="level-item">2.4.9 简述deque的内存管理策略</span></span></a></li><li><a class="level is-mobile" href="#2-4-10-简述deque、stack、queue的关系"><span class="level-left"><span class="level-item">2.4.10 简述deque、stack、queue的关系</span></span></a></li><li><a class="level is-mobile" href="#2-4-11-简述heap的实现原理"><span class="level-left"><span class="level-item">2.4.11 简述heap的实现原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-4-12-简述priority-queue的实现原理"><span class="level-left"><span class="level-item">2.4.12 简述priority_queue的实现原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-4-13-什么是关联式容器，有哪几类"><span class="level-left"><span class="level-item">2.4.13 什么是关联式容器，有哪几类</span></span></a></li><li><a class="level is-mobile" href="#2-4-14-简述set的特点及实现原理"><span class="level-left"><span class="level-item">2.4.14 简述set的特点及实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-15-★-简述map的特点及实现原理"><span class="level-left"><span class="level-item">2.4.15 ★ 简述map的特点及实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-16-简述哈希表的特点"><span class="level-left"><span class="level-item">2.4.16 简述哈希表的特点</span></span></a></li><li><a class="level is-mobile" href="#2-4-17-★-什么是碰撞问题，如何解决"><span class="level-left"><span class="level-item">2.4.17 ★ 什么是碰撞问题，如何解决</span></span></a></li><li><a class="level is-mobile" href="#2-4-18-★-简述hashtable的实现原理"><span class="level-left"><span class="level-item">2.4.18 ★ 简述hashtable的实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-19-简述hashtable的内存管理策略"><span class="level-left"><span class="level-item">2.4.19 简述hashtable的内存管理策略</span></span></a></li><li><a class="level is-mobile" href="#2-4-20-hashtable的键值可以任意取吗"><span class="level-left"><span class="level-item">2.4.20 hashtable的键值可以任意取吗</span></span></a></li><li><a class="level is-mobile" href="#2-4-21-简述hash-set-unordered-set-的特点及实现原理"><span class="level-left"><span class="level-item">2.4.21 简述hash_set(unordered_set)的特点及实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-22-★-简述hash-map-unordered-map-的特点及实现原理"><span class="level-left"><span class="level-item">2.4.22 ★ 简述hash_map(unordered_map)的特点及实现原理</span></span></a></li><li><a class="level is-mobile" href="#2-4-23-对比STL的各种容器"><span class="level-left"><span class="level-item">2.4.23 对比STL的各种容器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-5-算法"><span class="level-left"><span class="level-item">2.5 算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-5-1-简述什么是算法的泛型化"><span class="level-left"><span class="level-item">2.5.1 简述什么是算法的泛型化</span></span></a></li><li><a class="level is-mobile" href="#2-5-2-简述sort-算法的实现原理"><span class="level-left"><span class="level-item">2.5.2 简述sort()算法的实现原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-6-仿函数"><span class="level-left"><span class="level-item">2.6 仿函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-6-1-什么是仿函数，有什么作用"><span class="level-left"><span class="level-item">2.6.1 什么是仿函数，有什么作用</span></span></a></li><li><a class="level is-mobile" href="#2-6-2-如何定义一个仿函数"><span class="level-left"><span class="level-item">2.6.2 如何定义一个仿函数</span></span></a></li><li><a class="level is-mobile" href="#2-6-3-有哪些常见的仿函数"><span class="level-left"><span class="level-item">2.6.3 有哪些常见的仿函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-7-配接器"><span class="level-left"><span class="level-item">2.7 配接器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-对象模型"><span class="level-left"><span class="level-item">3 对象模型</span></span></a></li><li><a class="level is-mobile" href="#4-设计模式"><span class="level-left"><span class="level-item">4 设计模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-基础"><span class="level-left"><span class="level-item">4.1 基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-有哪些设计模式"><span class="level-left"><span class="level-item">4.1.1 有哪些设计模式</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-设计模式的设计原则"><span class="level-left"><span class="level-item">4.1.2 设计模式的设计原则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-单例模式"><span class="level-left"><span class="level-item">4.2 单例模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-什么是单例模式，什么时候应用"><span class="level-left"><span class="level-item">4.2.1 什么是单例模式，什么时候应用</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-实现思路"><span class="level-left"><span class="level-item">4.2.2 实现思路</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-不安全的实现方式（懒汉）"><span class="level-left"><span class="level-item">4.2.3 不安全的实现方式（懒汉）</span></span></a></li><li><a class="level is-mobile" href="#4-2-4-线程安全的实现方式（懒汉）"><span class="level-left"><span class="level-item">4.2.4 线程安全的实现方式（懒汉）</span></span></a></li><li><a class="level is-mobile" href="#4-2-5-饿汉模式实现（本身即线程安全）"><span class="level-left"><span class="level-item">4.2.5 饿汉模式实现（本身即线程安全）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-工厂模式"><span class="level-left"><span class="level-item">4.3 工厂模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-什么是简单工厂模式，什么时候应用"><span class="level-left"><span class="level-item">4.3.1 什么是简单工厂模式，什么时候应用</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-什么是工厂方法模式，什么时候应用"><span class="level-left"><span class="level-item">4.3.2 什么是工厂方法模式，什么时候应用</span></span></a></li><li><a class="level is-mobile" href="#4-3-3-什么是抽象工厂模式，什么时候应用"><span class="level-left"><span class="level-item">4.3.3 什么是抽象工厂模式，什么时候应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-4-观察者模式"><span class="level-left"><span class="level-item">4.4 观察者模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-4-1-什么是观察者模式，什么时候应用"><span class="level-left"><span class="level-item">4.4.1 什么是观察者模式，什么时候应用</span></span></a></li><li><a class="level is-mobile" href="#4-4-2-观察者模式的实现方式"><span class="level-left"><span class="level-item">4.4.2 观察者模式的实现方式</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithms-Notes/"><span class="tag">Algorithms-Notes</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cryptography/"><span class="tag">Cryptography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Divide-and-Conquer/"><span class="tag">Divide and Conquer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FFT/"><span class="tag">FFT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hashing/"><span class="tag">Hashing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Internet/"><span class="tag">Internet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Number-Theory/"><span class="tag">Number Theory</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sorting/"><span class="tag">Sorting</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Statistics/"><span class="tag">Statistics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-APP/"><span class="tag">Web APP</span><span class="tag">1</span></a></div></div></div></div></div> </div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a><p class="is-size-7"><span>&copy; 2023 Felix Feng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>