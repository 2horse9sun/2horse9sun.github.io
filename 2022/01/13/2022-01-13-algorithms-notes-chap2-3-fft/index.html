<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>chap 2-3 分治算法-多项式与快速傅里叶变换 - Felix Feng&#039;s Zone</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XU FENG&#039;S ZONE"><meta name="msapplication-TileImage" content="/images/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XU FENG&#039;S ZONE"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1. 信号处理在数字信号处理（Digital Signal Processing）领域中，经常使用到多项式乘法。信号通常是一个关于时间或位置的函数，比如捕获到的人的声音等等。数字信号处理要做的事情一般是，先对信号进行采样（sampling），使之变为离散信号；然后将离散信号输入到一个系统中（滤波器等等），最后得到系统的输出，我们称之为系统的响应（response）。"><meta property="og:type" content="blog"><meta property="og:title" content="chap 2-3 分治算法-多项式与快速傅里叶变换"><meta property="og:url" content="https://2horse9sun.github.io/2022/01/13/2022-01-13-algorithms-notes-chap2-3-fft/"><meta property="og:site_name" content="Felix Feng&#039;s Zone"><meta property="og:description" content="1. 信号处理在数字信号处理（Digital Signal Processing）领域中，经常使用到多项式乘法。信号通常是一个关于时间或位置的函数，比如捕获到的人的声音等等。数字信号处理要做的事情一般是，先对信号进行采样（sampling），使之变为离散信号；然后将离散信号输入到一个系统中（滤波器等等），最后得到系统的输出，我们称之为系统的响应（response）。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/signal_sampling.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/evaluation_and_interpolation.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/complex_roots_divide_and_conquer.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/FFT_recursive_tree.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/butterfly_operation.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/parallel_FFT.png"><meta property="og:image" content="https://2horse9sun.github.io/images/posts/polynomial_multiplication_FFT.png"><meta property="article:published_time" content="2022-01-12T16:00:00.000Z"><meta property="article:modified_time" content="2025-01-25T13:38:50.662Z"><meta property="article:author" content="Felix Feng"><meta property="article:tag" content="Algorithms-Notes"><meta property="article:tag" content="FFT"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/posts/signal_sampling.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://2horse9sun.github.io/2022/01/13/2022-01-13-algorithms-notes-chap2-3-fft/"},"headline":"chap 2-3 分治算法-多项式与快速傅里叶变换","image":["https://2horse9sun.github.io/images/posts/signal_sampling.png","https://2horse9sun.github.io/images/posts/evaluation_and_interpolation.png","https://2horse9sun.github.io/images/posts/complex_roots_divide_and_conquer.png","https://2horse9sun.github.io/images/posts/FFT_recursive_tree.png","https://2horse9sun.github.io/images/posts/butterfly_operation.png","https://2horse9sun.github.io/images/posts/parallel_FFT.png","https://2horse9sun.github.io/images/posts/polynomial_multiplication_FFT.png"],"datePublished":"2022-01-12T16:00:00.000Z","dateModified":"2025-01-25T13:38:50.662Z","author":{"@type":"Person","name":"Felix Feng"},"publisher":{"@type":"Organization","name":"Felix Feng's Zone","logo":{"@type":"ImageObject","url":"https://2horse9sun.github.io/images/site-logo.png"}},"description":"1. 信号处理在数字信号处理（Digital Signal Processing）领域中，经常使用到多项式乘法。信号通常是一个关于时间或位置的函数，比如捕获到的人的声音等等。数字信号处理要做的事情一般是，先对信号进行采样（sampling），使之变为离散信号；然后将离散信号输入到一个系统中（滤波器等等），最后得到系统的输出，我们称之为系统的响应（response）。"}</script><link rel="canonical" href="https://2horse9sun.github.io/2022/01/13/2022-01-13-algorithms-notes-chap2-3-fft/"><link rel="icon" href="/images/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6295a3485ca71319f7c2bb6050180382";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Blog</a><a class="navbar-item" href="/categories/Project">Project</a><a class="navbar-item" href="/categories/Essay">Essay</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold">chap 2-3 分治算法-多项式与快速傅里叶变换</h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-12T16:00:00.000Z" title="2022/1/13 00:00:00">2022-01-13</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span><i class="fas fa-eye"></i><span>  </span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style=""><h2 id="1-信号处理"><a href="#1-信号处理" class="headerlink" title="1. 信号处理"></a>1. 信号处理</h2><p>在数字信号处理（Digital Signal Processing）领域中，经常使用到多项式乘法。信号通常是一个关于时间或位置的函数，比如捕获到的人的声音等等。数字信号处理要做的事情一般是，先对信号进行采样（sampling），使之变为离散信号；然后将离散信号输入到一个系统中（滤波器等等），最后得到系统的输出，我们称之为系统的响应（response）。</p>
<span id="more"></span>

<p><img src="/images/posts/signal_sampling.png" alt="signal_sampling"></p>
<p>假设现在输入信号为$a(t)$，我们首先使用单位冲激（unit impulse）函数$\delta(t)$对$a(t)$进行采样：</p>
<p>$$<br>\begin{equation}<br>\delta(t)=<br>\begin{cases}<br> 1, &amp; t=0 \\ 0, &amp; t\neq 0<br>\end{cases}<br>\end{equation}<br>$$</p>
<p>若采样点数为$T$（为简化，暂且忽略采样间隔、归一化等细节），则对$a(t)$的采样为：</p>
<p>$$<br>a(t)=\sum_{i=0}^{T-1}a(i)\delta(t-i)<br>$$</p>
<p>下一步应该将离散信号输入到系统中，但是如何描述系统本身的性质？若把$\delta(t)$输入到系统中，会得到系统对于单位冲激信号的响应$b(t)$，我们称之为该系统的冲激响应（impulse response）。若系统是线性时不变的（linear and time-invariant），则$b(t)$可以描述该系统的性质；把$a(t)$输入系统，根据上述表达式可知，系统对于$a(t)$的响应完全取决于系统的冲激响应，因此在时刻$k$系统的输出应为：</p>
<p>$$<br>c(k)=\sum_{i=0}^{k}a(i)b(k-i)<br>$$</p>
<p>上述公式似乎非常眼熟。设有两个多项式$A(x)$和$B(x)$：</p>
<p>$$<br>A(x)=a_0+a_1x+a_2x^2+\cdots+a_dx^d<br>$$</p>
<p>$$<br>B(x)=b_0+b_1x+b_2x^2+\cdots+b_dx^d<br>$$</p>
<p>则它们相乘的结果$C(x)=A(x)\cdot B(x)=c_0+c_1x+c_2x^2+\cdots+c_{2d}x^{2d}$的系数满足：</p>
<p>$$<br>c_k=\sum_{i=0}^{k}a_ib_{k-i}<br>$$</p>
<p>其中若$i&gt;d$，则令$a_i,b_i=0$。这与系统响应函数的表达式完全相同，我们通常称这个操作为卷积（convolution），记为$c(t)=a(t)*b(t)$。卷积在数字信号处理中非常重要，加快卷积的计算速度也是必然要求。</p>
<p>如果按照上述方法求解两个$d$次多项式的乘法，复杂度为$\Theta(d^2)$，有没有可能降低复杂度呢？如果还是用列举系数来表示一个多项式的话，似乎很难再优化了，我们可以换一种思路，使用点值表示法。</p>
<h2 id="2-多项式乘法"><a href="#2-多项式乘法" class="headerlink" title="2. 多项式乘法"></a>2. 多项式乘法</h2><p>假设多项式$A(x)$的次数为$n-1$，系数表示法如下：</p>
<p>$$<br>A(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}<br>$$</p>
<p>该多项式可以唯一地被$n$个不同的点所确定，即：</p>
<p>$$<br>{(x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})}<br>$$</p>
<p>其中，$y_k=A(x_k),(k=0,1,\cdots,n-1)$且$x_k$各不相同。</p>
<p>$Proof$：本质上就是解如下的矩阵方程：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^{n-1} \\ 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{n-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; x_{n-1} &amp; x_{n-1}^2 &amp; \cdots &amp; x_{n-1}^{n-1} \<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_1  \\ \vdots  \\ a_{n-1}  \<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ \vdots  \\ y_{n-1}  \<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>左边的矩阵为范德蒙矩阵，因为$x_k$各不相同，该矩阵一定可逆，故可以确定唯一的一组系数向量$\mathbb{a}$。▮</p>
<p>如果我们一直使用点值表示法来描述多项式，那么多项式的乘法就变得非常简单了，直接对两组点做点值乘法。但是这样只能得到$n$个点，而得到的多项式应该是$2n-2$次的，故需要先对点值做扩展：</p>
<p>$$<br>A(x):{(x_0,y_0),(x_1,y_1),\cdots,(x_{2n-1},y_{2n-1})}<br>$$</p>
<p>$$<br>B(x):{(x_0,y_0’),(x_1,y_1’),\cdots,(x_{2n-1},y_{2n-1}’)}<br>$$</p>
<p>$$<br>C(x)=A(x)\cdot B(x):{(x_0,y_0y_0’),(x_1,y_1y_1’),\cdots,(x_{2n-1},y_{2n-1}y_{2n-1}’)}<br>$$</p>
<p>使用这个方法，多项式乘法的复杂度就能降到$\Theta(n)$。不幸的是，我们很少使用点值表示法，因为我们通常需要计算多项式在任意点处的值，而点值表示法只能给出$n$个点的值。</p>
<p><img src="/images/posts/evaluation_and_interpolation.png" alt="evaluation_and_interpolation"></p>
<p>换个思路，我们可以只在实行多项式乘法的时候使用点值表示法；也就是说，做乘法之前先分别对两个多项式进行$2n$个点的求值（evaluation），将它转化为点值表示，然后做点乘，最后对生成的$2n$个点进行插值(interpolation)，转化为系数表示：</p>
<ol>
<li>选择：挑选合适的$2n$个点$x_0,x_1,\cdots,x_{2n-1}$。</li>
<li>求值：计算$A(x_0),A(x_1),\cdots,A(x_{2n-1})$和$B(x_0),B(x_1),\cdots,B(x_{2n-1})$。</li>
<li>点乘：$C(x_k)=A(x_k)\cdot B(x_k)$。</li>
<li>插值：恢复$C(x)=c_0+c_1x+\cdots+c_{2n-2}x^{2n-2}$。</li>
</ol>
<p>使用这个方法，我们的主要矛盾就转移到了如何降低求值和插值的复杂度，整个算法的复杂度也取决于这两个步骤。</p>
<h2 id="3-多项式求值"><a href="#3-多项式求值" class="headerlink" title="3. 多项式求值"></a>3. 多项式求值</h2><p>对于多项式$A(x)$，给定$n$个不同的点$x_0,x_1,\cdots,x_{n-1}$，如何快速的求出$A(x_0),A(x_1),\cdots,A(x_{n-1})$是我们现在要解决的问题。使用霍纳法则：</p>
<p>$$<br>A(x_k)=a_0+x_k(a_1+x_k(a_2+\cdots+x_k(a_{n-2}+x_ka_{n-1})\cdots))<br>$$</p>
<p>求每个点的值花费$\Theta(n)$，求出全部的点的值需要$\Theta(n^2)$，仍然是太慢了。但是我们忽略了一点，我们是可以随意选择这些求值点的，是否存在某种选择方法可以让求值更快一些？</p>
<p>假设$n$为2的幂（若不是，就将多项式系数补零到刚大于$n$的那个2的幂），我们挑选这样的$n$个点：</p>
<p>$$<br>x_0,x_1,\cdots,x_{n/2-1}<br>$$</p>
<p>$$<br>-x_0,-x_1,\cdots,-x_{n/2-1}<br>$$</p>
<p>我们把$A(x)$按照系数位置下标的奇偶性分成两个部分：</p>
<p>$$<br>A_e(x^2)=a_0+a_2x^2+\cdots+a_{n-2}x^{n-2}<br>$$</p>
<p>$$<br>xA_o(x^2)=a_1x+a_3x^3+\cdots+a_{n-1}x^{n-1}<br>$$</p>
<p>则$A(x)$可以被表示为：</p>
<p>$$<br>A(x)=A_e(x^2)+xA_o(x^2)<br>$$</p>
<p>可以观察到：</p>
<p>$$<br>A(x_i)=A_e(x_i^2)+x_iA_o(x_i^2)<br>$$</p>
<p>$$<br>A(-x_i)=A_e(x_i^2)-x_iA_o(x_i^2)<br>$$</p>
<p>这说明，为了计算$A(x)$在$\pm x_0,\pm x_1,\cdots,\pm x_{n/2-1}$（$n$个点）处的值，我们只需要分别计算$A_e(x^2)$和$A_o(x^2)$在$x_0^2,x_1^2,\cdots,x_{n/2-1}^2$（$n/2$个点）处的值，即把一个大小为$n$的问题转化为了两个大小为$n/2$的子问题。如果该分治策略能够顺利进行下去，将有如下的递归关系式：</p>
<p>$$<br>T(n)=2T(n/2)+\Theta(n)<br>$$</p>
<p>最终的复杂度将为$\Theta(n\log n)$，确实大大降低。</p>
<p>但是这个方法只能分治一次，第一次分治我们利用加减号的对称性，将问题规模降到一半。第二次分治，我们需要对$x_0^2,x_1^2,\cdots,x_{n/2-1}^2$求值，但是我们再也不能找到一种分割方法，仅对一半点求值，就能计算出全部点的值。原因很显然，平方操作让这种加减对称性消失了。是否存在某些点，对其进行平方，仍然存在某种对称性？那就必须要引入复数了。</p>
<p>设复数$\omega$满足方程$\omega^n=1$，$n$次单位复数根恰好有$n$个，这些根为：</p>
<p>$$<br>\omega_n^k=e^{2\pi ik/n}<br>$$</p>
<p>我们称$\omega_n=e^{2\pi i/n}$为主$n$次单位根，其余根都是它的幂次。</p>
<p>若我们选取$\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1}$作为$n$个求值点，则可以推出：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>A(\omega_n^k)<br>&amp; = A_e(\omega_n^{2k})+\omega_n^kA_o(\omega_n^{2k}) \\ &amp;= A_e(\omega_{n/2}^{k})+\omega_n^kA_o(\omega_{n/2}^{k})<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>A(\omega_n^{k+n/2})<br>&amp; = A_e(\omega_n^{2k+n})+\omega_n^{k+n/2}A_o(\omega_n^{2k+n}) \\ &amp;= A_e(\omega_{n}^{2k})-\omega_n^kA_o(\omega_{n}^{2k}) \\ &amp;= A_e(\omega_{n/2}^{k})-\omega_n^kA_o(\omega_{n/2}^{k})<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>其中$k=0,1,2,\cdots,n/2-1$。</p>
<p><img src="/images/posts/complex_roots_divide_and_conquer.png" alt="complex_roots_divide_and_conquer"></p>
<p>为了计算$A(x)$在$\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1}$（$n$个点）处的值，我们只需要分别计算$A_e(x^2)$和$A_o(x^2)$在$\omega_{n/2}^0,\omega_{n/2}^1,\omega_{n/2}^2,\cdots,\omega_{n/2}^{n/2-1}$（$n/2$个点）处的值，并且可以一直分治下去。该算法的复杂度为$O(n\log n)$。</p>
<h2 id="4-快速傅里叶变换（FFT）"><a href="#4-快速傅里叶变换（FFT）" class="headerlink" title="4. 快速傅里叶变换（FFT）"></a>4. 快速傅里叶变换（FFT）</h2><p>假设有$n-1$次多项式$A(x)$：</p>
<p>$$<br>A(x)=\sum_{j=0}^{n-1}a_jx^j<br>$$</p>
<p>计算$A(x)$在$n$个$n$次单位复数根$\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1}$处的值，定义结果$y_k$：</p>
<p>$$<br>y_k=A(x_n^k)=\sum_{j=0}^{n-1}a_j\omega_n^{kj}<br>$$</p>
<p>则我们称向量$\mathbb{y}=(y_0,y_1,\cdots,y_{n-1})$就是系数向量$\mathbb{a}=(a_0,a_1,\cdots,a_{n-1})$的离散傅里叶变换（Discrete Fourier Transform, DFT），记为$y=DFT_n(\mathbb{a})$。（其他数字信号处理教材中，$\omega_n^{ki}$应该为$\omega_n^{-ki}$，算法导论里的没有负号，不过不影响）</p>
<p>我们按上述方法对多项式进行求值，其实就是对多项式系数做了一次DFT；采用上述分治法和利用复数根特殊性质来求解DFT的过程，被称为快速傅里叶变换（Fast Fourier Transform, FFT）。递归公式：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>y[k]<br>&amp; = y_e[k]+\omega_n^ky_o[k]<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>y[n/2+k]<br>&amp; = y_e[k]-\omega_n^ky_o[k]<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>下面是使用递归法求解向量$\mathbb{a}=(a_0,a_1,\cdots,a_{n-1})$的FFT的步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do_recursive_FFT</span>(a):</span><br><span class="line">	n = a.length</span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>: <span class="keyword">return</span> a</span><br><span class="line">	w_n为主n次单位根</span><br><span class="line">	w = <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	a_e = [a[<span class="number">0</span>], a[<span class="number">2</span>], ..., a[n<span class="number">-2</span>]]</span><br><span class="line">	a_o = [a[<span class="number">1</span>], a[<span class="number">3</span>], ..., a[n<span class="number">-1</span>]]</span><br><span class="line">	y_e = <span class="built_in">do_recursive_FFT</span>(a_e)</span><br><span class="line">	y_o = <span class="built_in">do_recursive_FFT</span>(a_o)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> k=<span class="number">0</span> to n/<span class="number">2</span><span class="number">-1</span>:</span><br><span class="line">		y[k] = y_e[k] + w*y_o[k]</span><br><span class="line">		y[k+n/<span class="number">2</span>] = y_e[k] - w*y_o[k]</span><br><span class="line">		w = w * w_n</span><br><span class="line">	<span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>

<p>下面我们再从矩阵的角度整体回顾一下FFT的原理。</p>
<p>对多项式$A(x)$在$x_0,x_1,\cdots,x_{n-1}$处取值，可以写成矩阵形式：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^{n-1} \\ 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{n-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; x_{n-1} &amp; x_{n-1}^2 &amp; \cdots &amp; x_{n-1}^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_1  \\ \vdots  \\ a_{n-1}<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>记矩阵为$M$。若在$n$个$n$次单位复数根$\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1}$处取值，即做DFT操作，则可以表达为：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\ 1 &amp; \omega_n^{1} &amp; \omega_n^{2} &amp; \omega_n^{3} &amp; \cdots &amp;  \omega_n^{n-1}  \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \omega_n^{6} &amp; \cdots &amp;  \omega_n^{2(n-1)}  \\ 1 &amp; \omega_n^{3} &amp; \omega_n^{6} &amp; \omega_n^{9} &amp; \cdots &amp;  \omega_n^{3(n-1)}  \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\ 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \omega_n^{3(n-1)} &amp; \cdots &amp;  \omega_n^{(n-1)(n-1)}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_1  \\ a_2 \\ a_3 \\ \vdots  \\ a_{n-1}<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>记矩阵为$M=M_n(\omega)$，其中$M(j,k)=\omega_n^{jk}$。在FFT算法中，我们首先根据系数下标的奇偶性，把系数分成了两个部分，重新排列系数矩阵的列以及系数向量的行：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; \cdots  &amp; 1 &amp; 1 &amp; 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots &amp; \omega_n^{1} &amp; \omega_n^{3} &amp;  \omega_n^{5} &amp; \cdots  \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots &amp; \omega_n^{2} &amp; \omega_n^{6} &amp;  \omega_n^{10} &amp; \cdots  \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots  \\ 1 &amp; \omega_n^{2n/2} &amp; \omega_n^{4n/2} &amp; \cdots &amp; \omega_n^{n/2} &amp;  \omega_n^{3n/2} &amp; \omega_n^{5n/2} &amp; \cdots \\ 1 &amp; \omega_n^{2n/2+2} &amp; \omega_n^{4n/2+4} &amp; \cdots &amp; \omega_n^{n/2+1} &amp;  \omega_n^{3n/2+3} &amp; \omega_n^{5n/2+5} &amp; \cdots \\ 1 &amp; \omega_n^{2n/2+4} &amp; \omega_n^{4n/2+8} &amp; \cdots &amp; \omega_n^{n/2+2} &amp;  \omega_n^{3n/2+6} &amp; \omega_n^{5n/2+10} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_2  \\ a_4 \\ \vdots \\ a_1 \\ a_3 \\ a_5 \\ \vdots<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>利用复数根的性质，继续化简上式：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; \cdots  &amp; \omega_n^{0}\cdot 1 &amp; \omega_n^{0}\cdot1 &amp; \omega_n^{0}\cdot1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots &amp; \omega_n^{1}\cdot 1 &amp; \omega_n^{1}\cdot\omega_n^{2} &amp;  \omega_n^{1}\cdot\omega_n^{4} &amp; \cdots  \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots &amp; \omega_n^{2}\cdot 1 &amp; \omega_n^{2}\cdot\omega_n^{4} &amp;  \omega_n^{2}\cdot\omega_n^{8} &amp; \cdots  \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots  \\ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; \omega_n^{n/2}\cdot 1 &amp;  \omega_n^{n/2}\cdot 1 &amp; \omega_n^{n/2}\cdot 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots &amp; \omega_n^{n/2+1}\cdot 1 &amp;  \omega_n^{n/2+1}\cdot\omega_n^{2} &amp; \omega_n^{n/2+1}\cdot\omega_n^{4} &amp; \cdots \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots &amp; \omega_n^{n/2+2}\cdot 1 &amp;  \omega_n^{n/2+2}\cdot\omega_n^{4} &amp; \omega_n^{n/2+2}\cdot\omega_n^{8} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_2  \\ a_4 \\ \vdots \\ a_1 \\ a_3 \\ a_5 \\ \vdots<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>观察发现，上式中的矩阵可以分成四个部分，每个部分都含有一个公共的矩阵$M_{n/2}(\omega^2)$：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix} y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}  \end{bmatrix} = \begin{bmatrix} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \begin{bmatrix} a_0  \\ a_2  \\ a_4 \\ \vdots \end{bmatrix} + \begin{bmatrix} \omega_n^{0} \\ \omega_n^{1} \\ \omega_n^{2} \\ \vdots \end{bmatrix}^T \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \begin{bmatrix} a_1 \\ a_3 \\ a_5 \\ \vdots<br>\end{bmatrix} \\ \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \begin{bmatrix} a_0  \\ a_2  \\ a_4 \\ \vdots \end{bmatrix} - \begin{bmatrix}<br>\omega_n^{0} \\ \omega_n^{1} \\ \omega_n^{2} \\ \vdots \end{bmatrix}^T \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \cdots \\ 1 &amp; \omega_n^{4} &amp; \omega_n^{8} &amp; \cdots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix} \begin{bmatrix} a_1 \\ a_3 \\ a_5 \\ \vdots \end{bmatrix} \end{bmatrix} \end{equation}<br>$$</p>
<p>即：</p>
<p>$$<br>\begin{equation} \begin{bmatrix} y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1} \end{bmatrix} = M_n(\omega) \begin{bmatrix} a_0  \\ a_1  \\ a_2 \\ a_3 \\ a_4 \\ \vdots  \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} M_{n/2}(\omega^2) \begin{bmatrix} a_0  \\ a_2  \\ a_4 \\ \vdots \end{bmatrix} + \begin{bmatrix} \omega_n^{0} \\ \omega_n^{1} \\ \omega_n^{2} \\ \vdots \end{bmatrix}^T M_{n/2}(\omega^2) \begin{bmatrix} a_1 \\ a_3 \\ a_5 \\ \vdots \end{bmatrix} \\ M_{n/2}(\omega^2) \begin{bmatrix} a_0  \\ a_2  \\ a_4 \\ \vdots \end{bmatrix} - \begin{bmatrix} \omega_n^{0} \\ \omega_n^{1} \\ \omega_n^{2} \\ \vdots \end{bmatrix}^T M_{n/2}(\omega^2) \begin{bmatrix} a_1 \\ a_3 \\ a_5 \\ \vdots \end{bmatrix} \end{bmatrix} \end{equation}<br>$$</p>
<p>观察发现，FFT的本质就是把$M_n(\omega)$乘以向量$(a_0,a_1,\cdots,a_{n-1})^T$的问题转化成了$M_{n/2}(\omega^2)$乘以向量$(a_0,a_2,\cdots,a_{n-2})^T$和$M_{n/2}(\omega^2)$乘以向量$(a_1,a_3,\cdots,a_{n-1})^T$的两个子问题，有如下的递归关系式：</p>
<p>$$<br>T(n)=2T(n/2)+\Theta(n)<br>$$</p>
<p>最终的复杂度为$\Theta(n\log n)$。</p>
<h2 id="5-高效FFT实现"><a href="#5-高效FFT实现" class="headerlink" title="5. 高效FFT实现"></a>5. 高效FFT实现</h2><p>在实际应用中，DFT同时要求较低的时间和空间复杂度，FFT的递归实现占用大量空间，下面介绍FFT的迭代实现方法，将比递归版快一些，而且占用更少的空间。</p>
<p>首先分析一下递归FFT的运行过程，画出如下的递归树：</p>
<p><img src="/images/posts/FFT_recursive_tree.png" alt="FFT_recursive_tree"></p>
<p>我们需要模拟递归中自底向上的计算过程。首先注意到，数组元素的次序在最底层是被打乱的，出现的顺序是原数组的位逆序置换。比如做8点DFT时，最底层的第001（1）个元素应该是原数组的第100（4）个元素。实际操作中，通常提前准备好bit-reverse lookup table，达到$O(1)$的位逆序置换速度。</p>
<p><img src="/images/posts/butterfly_operation.png" alt="butterfly_operation"></p>
<p>从最底层开始，成对取出元素，做一次蝴蝶操作计算出每对的DFT，用其DFT取代这对元素：</p>
<p>$$<br>t =\omega_n^ky_o[k]<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>y[k]<br>&amp; = y_e[k]+t<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>y[n/2+k]<br>&amp; = y_e[k]-t<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>这样向量中就包含了$n/2$个二元素的DFT。然后，按对取出这$n/2$个元素的DFT，通过两次蝴蝶操作计算出四元素向量的DFT。以此类推，最终我们就得到了一个具有$n$元素的DFT。</p>
<p>设当前自底向上所处递归树的层次为$s$，最底层为$s=1$，则每次应该取出$m=2^s$个元素做蝴蝶操作。每次蝴蝶操作就是把$A[k:k+m/2-1]$和$A[k+m/2:k+m-1]$两个数组合并成$A[k:k+m-1]$。伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do_iterative_FFT</span>(a):</span><br><span class="line">	A = <span class="built_in">bit_reverse</span>(a)</span><br><span class="line">	n = a.length</span><br><span class="line">	<span class="keyword">for</span> s=<span class="number">1</span> to <span class="built_in">log2</span>(n):</span><br><span class="line">		m = <span class="number">2</span>^s</span><br><span class="line">		w_m为主m次单位根</span><br><span class="line">		<span class="keyword">for</span> k = <span class="number">0</span> to n<span class="number">-1</span> by m:</span><br><span class="line">			w = <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">0</span> to m/<span class="number">2</span><span class="number">-1</span>:</span><br><span class="line">				u = A[k+j]</span><br><span class="line">				t = A[k+m/<span class="number">2</span>+j]</span><br><span class="line">				A[k+j] = u + t</span><br><span class="line">				A[k+m/<span class="number">2</span>+j] = u - t</span><br><span class="line">				w = w * w_m</span><br><span class="line"><span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>

<p>复杂度计算：</p>
<p>$$<br>T(n)=\sum_{s=1}^{\log n}\frac{n}{2^s}\cdot 2^{s-1}=\Theta(n\log n)<br>$$</p>
<p>再次观察递归树，我们发现每一层的计算其实可以改为并行操作，因为它们之间没有依赖性。故可以设计出下面的并行FFT电路，深度为$\Theta(\log n)$级，这也是实际硬件中使用的电路模型：</p>
<p><img src="/images/posts/parallel_FFT.png" alt="parallel_FFT"></p>
<h2 id="5-多项式插值与IFFT"><a href="#5-多项式插值与IFFT" class="headerlink" title="5. 多项式插值与IFFT"></a>5. 多项式插值与IFFT</h2><p>回到多项式乘法的主题上来，我们使用了FFT使对$2n$个点求值这一步的复杂度降低到了$\Theta(n\log n)$，之后对这$2n$个点进行点乘。现在还差最后一步操作，就是对$2n$个点插值，得到乘积多项式的系数向量。再次回顾一下这个等式：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\ 1 &amp; \omega_n^{1} &amp; \omega_n^{2} &amp; \omega_n^{3} &amp; \cdots &amp;  \omega_n^{n-1}  \\ 1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \omega_n^{6} &amp; \cdots &amp;  \omega_n^{2(n-1)}  \\ 1 &amp; \omega_n^{3} &amp; \omega_n^{6} &amp; \omega_n^{9} &amp; \cdots &amp;  \omega_n^{3(n-1)}  \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\ 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \omega_n^{3(n-1)} &amp; \cdots &amp;  \omega_n^{(n-1)(n-1)}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0  \\ a_1  \\ a_2 \\ a_3 \\ \vdots  \\ a_{n-1}<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>现在我们知道了$\mathbb{y}$和$M_n(\omega)$，需要求出$\mathbb{a}$。由于$M_n(\omega)$一定可逆，所以：</p>
<p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>a_0  \\ a_1  \\ a_2 \\ a_3 \\ \vdots  \\ a_{n-1}<br>\end{bmatrix}<br>=<br>M_n(\omega)^{-1}<br>\begin{bmatrix}<br>y_0  \\ y_1  \\ y_2 \\ y_3 \\ \vdots  \\ y_{n-1}<br>\end{bmatrix}<br>\end{equation}<br>$$</p>
<p>那么$M_n(\omega)$的逆矩阵等于多少呢？我们构造一个矩阵$M_n(\omega)^*$，里面的每个元素都是$M_n(\omega)$对应元素的共轭。那么$M_n(\omega)M_n(\omega)^*$的$(j,k)$位置元素的值为：</p>
<p>$$<br>1+\omega_n^{j-k}+\omega_n^{2(j-k)}+\omega_n^{3(j-k)}+\cdots+\omega_n^{(n-1)(j-k)}<br>$$</p>
<p>当$j=k$时，结果为$n$；当$j\neq k$时，结果为$(1-\omega_n^{n(j-k)})/(1-\omega_n^{j-k})=0$，这说明$M_n(\omega)$的所有列都是互相正交的。我们发现：</p>
<p>$$<br>M_n(\omega)M_n(\omega)^*=nI<br>$$</p>
<p>可以看出，$M_n(\omega)^{-1}=\frac{1}{n}M_n(\omega)^*=\frac{1}{n}M_n(\omega^{-1})$。利用这个结论，可以直接写出逆DFT的表达式：</p>
<p>$$<br>\mathbb{a}=DFT^{-1}_n(\mathbb{y})<br>$$</p>
<p>$$<br>a_k=\frac{1}{n}\sum_{j=0}^{n-1}y_j\omega_n^{-jk}<br>$$</p>
<p>计算逆FFT的方式很简单，在原FFT程序中将$\mathbb{a}$和$\mathbb{y}$互换，用$\omega_n^{-1}$替换$\omega_n$，并将计算结果的每个元素都除以$n$即可。复杂度仍然是$\Theta(n\log n)$。</p>
<p>总结一下，多项式乘法的过程可以用卷积定理来说明：</p>
<blockquote>
<p>对于任意两个向量$\mathbb{a}$和$\mathbb{b}$，将它们的长度补零至$2n$，$n$为2的幂，则：</p>
<p>$$<br>\mathbb{a}*\mathbb{b}=DFT_{2n}^{-1}(DFT_{2n}(\mathbb{a})\cdot DFT_{2n}(\mathbb{b}))<br>$$</p>
<p>其中$*$表示卷积，$\cdot$表示点乘。计算DFT的过程可以使用FFT算法。</p>
</blockquote>
<p>下面的图也清晰地描述了使用FFT求解多项式乘法的过程：</p>
<p><img src="/images/posts/polynomial_multiplication_FFT.png" alt="polynomial_multiplication_FFT"></p>
<p>我们把多项式中的$x$换成$2$或者$10$，可以发现多项式的系数向量可以表示一个以2或10为base的数，这就意味着可以使用FFT求解整数乘法，复杂度为$\Theta(n\log n)$，比以前介绍过的任何一种乘法算法都要快！</p>
<p>Quick Link: <a href="https://2horse9sun.github.io/2021/12/19/2021-12-19-algorithms-notes-overview/">算法笔记整理</a></p>
</div><hr style="height:1px;margin:1rem 0"></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/17/2022-01-17-algorithms-notes-chap2-4-application/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">chap 2-3 分治算法-综合应用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/08/2022-01-08-algorithms-notes-chap2-2-sort_and_select/"><span class="level-item">chap 2-2 分治算法-排序和选择</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Felix Feng"></figure><p class="title is-size-4 is-block" style="font-weight: bold">Felix Feng</p><p class="is-size-6 is-block" style="margin-top: 1rem">jsjhfx@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Posts</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Tags</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/2horse9sun" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/2horse9sun"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="is-4-tablet is-4-desktop is-3-widescreen  is-sticky" style="margin-top: 1.5rem"> <div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-信号处理"><span class="level-left"><span class="level-item">1. 信号处理</span></span></a></li><li><a class="level is-mobile" href="#2-多项式乘法"><span class="level-left"><span class="level-item">2. 多项式乘法</span></span></a></li><li><a class="level is-mobile" href="#3-多项式求值"><span class="level-left"><span class="level-item">3. 多项式求值</span></span></a></li><li><a class="level is-mobile" href="#4-快速傅里叶变换（FFT）"><span class="level-left"><span class="level-item">4. 快速傅里叶变换（FFT）</span></span></a></li><li><a class="level is-mobile" href="#5-高效FFT实现"><span class="level-left"><span class="level-item">5. 高效FFT实现</span></span></a></li><li><a class="level is-mobile" href="#5-多项式插值与IFFT"><span class="level-left"><span class="level-item">5. 多项式插值与IFFT</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithms-Notes/"><span class="tag">Algorithms-Notes</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cryptography/"><span class="tag">Cryptography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Divide-and-Conquer/"><span class="tag">Divide and Conquer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FFT/"><span class="tag">FFT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hashing/"><span class="tag">Hashing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Internet/"><span class="tag">Internet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Number-Theory/"><span class="tag">Number Theory</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sorting/"><span class="tag">Sorting</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Statistics/"><span class="tag">Statistics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-APP/"><span class="tag">Web APP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-APP/"><span class="tag">iOS APP</span><span class="tag">2</span></a></div></div></div></div></div> </div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a><p class="is-size-7"><span>&copy; 2025 Felix Feng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>