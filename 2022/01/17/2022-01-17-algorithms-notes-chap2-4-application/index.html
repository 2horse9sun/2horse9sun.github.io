<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>chap 2-3 分治算法-综合应用 - Felix Feng&#039;s Zone</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XU FENG&#039;S ZONE"><meta name="msapplication-TileImage" content="/images/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XU FENG&#039;S ZONE"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1. 满二叉树的数量定义满二叉树：所有节点要么有两个子节点，要么无子节点。设$B_n$表示共$n$节点的不同满二叉树的数量，则： $$B_{n+2}&amp;#x3D;\sum_{i&amp;#x3D;1}^{n+1}B_{i}B_{n+1-i}$$ 假设根节点固定，则$n+2$个节点的满二叉树数量，取决于根节点的左子树和右子树（都为满二叉树）的组合数量。使用数学归纳法可证，复杂度为$\Omega(2^n)$。我们可以使用额外的空间"><meta property="og:type" content="blog"><meta property="og:title" content="chap 2-3 分治算法-综合应用"><meta property="og:url" content="https://2horse9sun.github.io/2022/01/17/2022-01-17-algorithms-notes-chap2-4-application/"><meta property="og:site_name" content="Felix Feng&#039;s Zone"><meta property="og:description" content="1. 满二叉树的数量定义满二叉树：所有节点要么有两个子节点，要么无子节点。设$B_n$表示共$n$节点的不同满二叉树的数量，则： $$B_{n+2}&amp;#x3D;\sum_{i&amp;#x3D;1}^{n+1}B_{i}B_{n+1-i}$$ 假设根节点固定，则$n+2$个节点的满二叉树数量，取决于根节点的左子树和右子树（都为满二叉树）的组合数量。使用数学归纳法可证，复杂度为$\Omega(2^n)$。我们可以使用额外的空间"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://2horse9sun.github.io/img/og_image.png"><meta property="article:published_time" content="2022-01-16T16:00:00.000Z"><meta property="article:modified_time" content="2022-01-19T13:25:55.042Z"><meta property="article:author" content="Felix Feng"><meta property="article:tag" content="Algorithms-Notes"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://2horse9sun.github.io/2022/01/17/2022-01-17-algorithms-notes-chap2-4-application/"},"headline":"chap 2-3 分治算法-综合应用","image":["https://2horse9sun.github.io/img/og_image.png"],"datePublished":"2022-01-16T16:00:00.000Z","dateModified":"2022-01-19T13:25:55.042Z","author":{"@type":"Person","name":"Felix Feng"},"publisher":{"@type":"Organization","name":"Felix Feng's Zone","logo":{"@type":"ImageObject","url":"https://2horse9sun.github.io/images/site-logo.png"}},"description":"1. 满二叉树的数量定义满二叉树：所有节点要么有两个子节点，要么无子节点。设$B_n$表示共$n$节点的不同满二叉树的数量，则： $$B_{n+2}&#x3D;\\sum_{i&#x3D;1}^{n+1}B_{i}B_{n+1-i}$$ 假设根节点固定，则$n+2$个节点的满二叉树数量，取决于根节点的左子树和右子树（都为满二叉树）的组合数量。使用数学归纳法可证，复杂度为$\\Omega(2^n)$。我们可以使用额外的空间"}</script><link rel="canonical" href="https://2horse9sun.github.io/2022/01/17/2022-01-17-algorithms-notes-chap2-4-application/"><link rel="icon" href="/images/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6295a3485ca71319f7c2bb6050180382";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Blog</a><a class="navbar-item" href="/categories/Project">Project</a><a class="navbar-item" href="/categories/Essay">Essay</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold">chap 2-3 分治算法-综合应用</h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-16T16:00:00.000Z" title="2022-1-17 12:00:00 ├F10: AM┤">2022-01-17</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span><i class="fas fa-eye"></i><span>  </span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style=""><h2 id="1-满二叉树的数量"><a href="#1-满二叉树的数量" class="headerlink" title="1. 满二叉树的数量"></a>1. 满二叉树的数量</h2><p>定义满二叉树：所有节点要么有两个子节点，要么无子节点。设$B_n$表示共$n$节点的不同满二叉树的数量，则：</p>
<p>$$<br>B_{n+2}=\sum_{i=1}^{n+1}B_{i}B_{n+1-i}<br>$$</p>
<p>假设根节点固定，则$n+2$个节点的满二叉树数量，取决于根节点的左子树和右子树（都为满二叉树）的组合数量。使用数学归纳法可证，复杂度为$\Omega(2^n)$。我们可以使用额外的空间保存下$B_i$的值，这样可以减少重复计算次数。</p>
<span id="more"></span>

<h2 id="2-二分查找模板"><a href="#2-二分查找模板" class="headerlink" title="2. 二分查找模板"></a>2. 二分查找模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= n || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无限数列中的搜索"><a href="#3-无限数列中的搜索" class="headerlink" title="3. 无限数列中的搜索"></a>3. 无限数列中的搜索</h2><p>给定无限数列$A[\cdot]$，前$n$个元素都是有序的整数，后面的无限个元素都是$\infty$，且$n$是未知的。设计一个复杂度为$O(\log n)$的查找算法。</p>
<p>依次访问以下元素：$A[0], A[1],A[2],A[4],A[8],\cdots,A[2^{k-1}],A[2^k]$，直至$A[2^k]=\infty$，则$2^{k-1}\leq n-1 &lt; 2^k$。在$A[2^{k-1},\cdots,2^k]$范围内做二分搜索，可以在$O(\log n)$内找到$n$。得知$n$后，就可以使用二分搜索在$O(\log n)$内查找任意元素。</p>
<h2 id="4-搜索复杂度下界"><a href="#4-搜索复杂度下界" class="headerlink" title="4. 搜索复杂度下界"></a>4. 搜索复杂度下界</h2><p>类比排序算法，基于比较的搜索算法也可以用决策树模型来描述。二叉树至少有$n$个叶子节点，每个叶子节点代表查找到的索引值，每个非叶子节点代表一次比较操作，二叉树的高度代表搜索次数，故复杂度为$\Omega(\log n)$。</p>
<h2 id="5-k-way-merge"><a href="#5-k-way-merge" class="headerlink" title="5. k-way merge"></a>5. k-way merge</h2><p>给定$k$个有序数组，每个数组都是$n$个元素，设计算法将其合并成一个具有$kn$个元素的有序数组。</p>
<p>第一种做法：为了选出最小的元素，比较所有数组的第一个元素（$k-1$次）。每次比较的时间为$O(k)$，共需选出$O(kn)$个元素，总复杂度为$(k^2n)$。</p>
<p>第二种做法：顺序合并，第一个数组先和第二个数组合并，将合并的结果与第三个数组合并…… 令$T(i)$表示合并数组$1~i$的时间，则$T(i)\leq T(i-1)+O(ni)$，总复杂度为$O(k^2n)$。</p>
<p>第三种做法：使用分治法，两两合并，将合并的结果再两两合并…… 递归表达式：$T(k)=2T(k/2)+O(nk)$，复杂度为$O(nk\log k)$。</p>
<p>第四种做法：使用堆实现的优先队列。先把$k$个有序数组的第一个元素输入优先队列中，复杂度为$O(k\log k)$。接下来，可以在$O(\log k)$时间内，完成优先队列的push、pop操作，共需进行$kn$次，故总复杂度为$O(nk\log k)$。</p>
<p>第五种做法：使用败者树（类似于堆），步骤类似于第四种做法，总复杂度为$O(nk\log k)$。虽然渐进意义上复杂度和优先队列相同，但是这种做法相较于优先队列，总的比较次数要略小。</p>
<h2 id="6-线性时间排序"><a href="#6-线性时间排序" class="headerlink" title="6. 线性时间排序"></a>6. 线性时间排序</h2><p>如果排序算法基于元素比较，那么复杂度的下界为$\Omega(n\log n)$。下面介绍几种不基于比较的算法，复杂度可以轻松突破$\Omega(n\log n)$的下界。</p>
<h3 id="6-1-计数排序（counting-sort）"><a href="#6-1-计数排序（counting-sort）" class="headerlink" title="6.1 计数排序（counting sort）"></a>6.1 计数排序（counting sort）</h3><p>假设数组$a$有$n$个元素，每个元素都是在$[0:k]$区间内的一个整数。计数排序的基本思想就是：对于每个输入元素$a[i]$，计算出原数组中小于等于它的元素个数，就可以直接把它放在结果数组的正确位置上了。主要步骤：</p>
<ol>
<li>建立数组$c[0:k]$，全部初始化为0。遍历数组$a$，每次遇到$a[i]$，就在$c[a[i]]$上加1。遍历完后，$c[i]$存储的就是$i$在数组$a$中出现的次数。</li>
<li>从前往后遍历$c[i]$，对于每个$c[i]$，令$c[i]=c[i]+c[i-1]$，此时$c[i]$表示数组$a$中$\leq i$的元素个数，且$c[k]=n$。</li>
<li>建立数组$b$存储结果，从后往前遍历数组$a$，对于$a[i]$，应该有$c[a[i]]$个元素小于等于它，所以它在最终结果中的下标应该是$c[a[i]]-1$，故$b[c[a[i]]-1]=a[i]$。由于$a[i]$已经被填入结果数组中，所以$c[a[i]]$的值应该减1。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">int</span>* c = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) c[a[i]]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		b[c[a[i]]<span class="number">-1</span>] = a[i];</span><br><span class="line">		c[a[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i];</span><br><span class="line">	<span class="keyword">delete</span>[] b; <span class="keyword">delete</span>[] c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易看出，复杂度为$\Theta(n+k)$。若$k=O(n)$，则复杂度为$\Theta(n)$。</p>
<p>注意到在步骤3中，我们从后往前遍历数组$a$，是为了保证排序的稳定性：具有相同值的元素在输出数组中的相对次序和在输入数组中的相对次序相同。若我们从前往后遍历数组$a$，相同的元素在输出数组中相对于之前就是逆序的。</p>
<p>为什么需要保证排序稳定性？如果元素只表示数字的话，可以不用考虑。但是在实际应用中，需要排序的元素可能是一个个复杂对象，实际参与排序的元素只是一个句柄（handle），可能是对象指针或一个整数，一个句柄关联一个对象。如果这些对象本来具有某种顺序，排序不稳定的话就会破坏这种顺序。</p>
<h3 id="6-2-基数排序（radix-sort）"><a href="#6-2-基数排序（radix-sort）" class="headerlink" title="6.2 基数排序（radix sort）"></a>6.2 基数排序（radix sort）</h3><p>给定一个数组，数组元素都是日期时间格式（yyyy-MM-dd HH:mm:ss），需要按照时间先后顺序对其进行排序。第一种方法是，先按照年排序，年相同的再按照月排序，月相同的…… 另一种方法便是基数排序，使用一种稳定排序算法对这些信息进行6次排序，先秒，再分，后小时…… 这种多关键字域的排序可以考虑使用基数排序。</p>
<p>对于一般的整数排序，也可以使用基数排序。给定$n$个$d$位整数（第一位为最低位，第$d$位为最高位），我们可以先使用稳定排序对第1位排序，然后对第2位排序，直至第$d$位。举例，下面有一组数：</p>
<p>$$<br>329,457,657,839,436,720,355<br>$$</p>
<p>我们先对最低位排序（9，7，7，9，6，0，5）：</p>
<p>$$<br>720,355,436,457,657,329,839<br>$$</p>
<p>然后对第2位排序（2，5，3，5，5，2，3）：</p>
<p>$$<br>720,329,436,839,355,457,657<br>$$</p>
<p>最后对最高位排序（7，3，4，8，3，4，6）：</p>
<p>$$<br>329,355,436,457,657,720,839<br>$$</p>
<p>基数排序的伪代码如下，$A$为$n$个$d$位元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function radix_sort(A, d):</span><br><span class="line">	for i = 1 to d:</span><br><span class="line">		stable_sort(A) on digit i</span><br></pre></td></tr></table></figure>

<p>基数排序先按最低有效位进行排序确实有点反直觉，不过只要保证中间排序是稳定的，就可以得到正确结果。</p>
<p>$Proof$：使用数学归纳法，假设按数组元素的最低$i-1$个有效位排序后数组是有序的，下面按第$i$位进行排序。若两个元素的第$i$位不同，排序的结果一定是正确的，不用考虑最低$i-1$个有效位是否排序过以及排序是否稳定。若两个元素的第$i$位相同，排序结果取决于最低$i-1$个有效位的排序结果。由于排序是稳定的，第$i$位相同时，元素的相对次序不会改变，而且我们假设数组元素的最低$i-1$个有效位排序后数组是有序的，故按第$i$位进行排序后排序结果也正确。▮</p>
<p>对$n$个$b$位整数排序时，我们也可以把一个$b$位数分成$d=\lceil b/r \rceil$个$r$位数，每个$r$位数都在区间$[0,2^r-1]$中，可以采用计数排序（稳定，$k=2^r-1$）作为中间排序。每一轮排序时间为$\Theta(n+2^r)$，需要$d$轮，总时间为$\Theta((b/r)(n+2^r))$。若$b=O(\log n)$，我们选择$r=O(\log n)$，基数排序的运行时间就为$\Theta(n)$。</p>
<p>虽然以计数排序作为中间稳定排序的基数排序运行时间是线性，我们大多数时候仍采用快速排序。因为快速排序是原址的，只需要固定的额外空间，而基数排序要占用大量空间，且输入数据的个数满足一定条件才能达到线性时间。</p>
<h3 id="6-3-桶排序（bucket-sort）"><a href="#6-3-桶排序（bucket-sort）" class="headerlink" title="6.3 桶排序（bucket sort）"></a>6.3 桶排序（bucket sort）</h3><p>假设输入数据符合均匀分布，我们可以使用桶排序。输入数组$A$的$n$个元素由随机过程产生，独立地分布在区间$[0,1)$上。主要步骤：</p>
<ol>
<li>将区间$[0,1)$划分为$n$个相同大小的区间，称为桶。桶数组记为$B$，每个元素是一个链表结构。</li>
<li>依次将$A[i]$放入到对应的桶中，对应桶的下标为$\lfloor nA[i]\rfloor$。由于输入均匀分布，每个桶中的元素应该差不多。</li>
<li>对每个桶中的元素进行插入排序。</li>
<li>遍历每个桶，依次取出桶中的元素，合成一个数组。</li>
</ol>
<p>复杂度不太容易能看出来，步骤1，2，4的复杂度都是$O(n)$，下面重点求解步骤3的平均复杂度。</p>
<p>假设$n_i$表示桶$B[i]$中元素的个数，步骤3的时间为：</p>
<p>$$<br>T(n)=\Theta(n)+\sum_{i=0}^{n-1}O(n_i^2)<br>$$</p>
<p>$$<br>E[T(n)]=\Theta(n)+\sum_{i=0}^{n-1}O(E[n_i^2])<br>$$</p>
<p>定义指示变量$X_{ij}=I(A[j]落入桶i)$，则：</p>
<p>$$<br>n_i=\sum_{j=1}^nX_{ij}<br>$$</p>
<p>下面求解$E[n_i^2]$：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>E[n_i^2]<br>&amp; = E[\sum_{j=1}^n\sum_{k=1}^nX_{ij}X_{ik}] \\ &amp;= E[\sum_{j=1}^nX_{ij}^2+\sum_{1\leq j\leq n}\sum_{1\leq k\leq n,k\neq j}X_{ij}X_{ik}] \\ &amp;= \sum_{j=1}^nE[X_{ij}^2]+\sum_{1\leq j\leq n}\sum_{1\leq k\leq n,k\neq j}E[X_{ij}X_{ik}] \\ &amp;= \sum_{j=1}^nE[X_{ij}^2]+\sum_{1\leq j\leq n}\sum_{1\leq k\leq n,k\neq j}E[X_{ij}]E[X_{ik}] \\ &amp;= [1^2\cdot \frac{1}{n}+0^2\cdot(1-\frac{1}{n})]+n(n-1)\cdot\frac{1}{n}\cdot\frac{1}{n} \\ &amp;= 2-\frac{1}{n}<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>故总复杂度：</p>
<p>$$<br>\Theta(n)+n\cdot O(2-\frac{1}{n})=\Theta(n)<br>$$</p>
<p>我们基于的假设是输入数据符合均匀分布。观察上述推导过程，其实只要$\sum_{i=0}^{n-1}O(n_i^2)$为线性就可以，即所有桶的大小的平方和与总元素数呈线性关系。</p>
<h2 id="7-中位数和平均数"><a href="#7-中位数和平均数" class="headerlink" title="7. 中位数和平均数"></a>7. 中位数和平均数</h2><p>统计学中的一个重要任务就是使用单独的一个量$\mu$来描述一组观测值$x_1,x_2,\cdots,x_n$。最常用的两种统计量就是中位数$\mu_1$和平均数$\mu_2$。</p>
<p>中位数的性质：</p>
<p>$$<br>\mu_1={\arg\min}<em>{\mu}\sum</em>{i=1}^{n}|x_i-\mu|<br>$$</p>
<p>$Proof$：假设$\mu&gt;\mu_1$，令$\mu$往$\mu_1$的方向移动一个极小的偏移量$\epsilon$，则所有$x_i&lt;\mu$的$x_i$到$\mu$的距离都减少了$\epsilon$，所有$x_i&gt;\mu$的$x_i$到$\mu$的距离都增大了$\epsilon$。由于$\mu&gt;\mu_1$，比$\mu$小的$x_i$的数量一定不小于比$\mu$大的$x_i$的数量，故总距离应该是单调递减的。同理，假设$\mu&lt;\mu_1$，则令$\mu$往$\mu_1$的方向移动时，总距离也是单调递减的。故上述性质成立。▮</p>
<p>平均数的性质：</p>
<p>$$<br>\mu_2={\arg\min}<em>{\mu}\sum</em>{i=1}^{n}(x_i-\mu)^2<br>$$</p>
<p>$Proof$：通过推导，可以得出：</p>
<p>$$<br>\sum_{i=1}^{n}(x_i-\mu)^2=\sum_{i=1}^{n}(x_i-\mu_2)^2+n(\mu-\mu_2)^2<br>$$</p>
<p>当$\mu=\mu_2$时，上式取最小值，故结论成立。▮ </p>
<p>从这个性质也可以看出，平均数非常容易受观测序列中离群值（outlier）的影响。</p>
<h2 id="8-两个有序数组的-k-th-smallest-element"><a href="#8-两个有序数组的-k-th-smallest-element" class="headerlink" title="8. 两个有序数组的$k$th smallest element"></a>8. 两个有序数组的$k$th smallest element</h2><p>给定两个升序数组$a$和$b$，长度分别为$m$和$n$，设计算法求出两个数组的并集的第$k$小的元素，复杂度为$O(\log k)$。</p>
<p>首先缩小搜索范围，两个数组的并集的第$k$小的元素一定在$a[0:k-1]$和$b[0:k-1]$之中（若$m&lt;k$或$n&lt;k$，就把不足$k$的部分设置成$\infty$）。需要求解的问题：在$a[0:k-1]$和$b[0:k-1]$的并集中寻找第$k$小的元素。</p>
<p>令$k_f=\lfloor k/2 \rfloor, k_c=\lceil k/2 \rceil$（$k_f+k_c=k$），比较$a[k_f-1]$和$b[k_c-1]$的大小。</p>
<ol>
<li><p>若$a[k_f-1]&gt;b[k_c-1]$，说明了$a[k_f-1]&gt;b[0:k_c-1]$共$k_c$个元素，可以推出比$b[k_c-1]$还要小的元素最多只可能有$k-2$个：$b[0:k_c-2]$和$a[0:k_f-2]$。因此，第$k$小的元素一定$&gt;b[k_c-1]$。由于$a[k_f-1]$是$a[0:k_f-1]$和$b[0:k_c-1]$中最大的，且这两个区间共有$k$个元素，故第$k$小的元素一定$\leq a[k_f-1]$。</p>
<p>综上所述，原问题被缩减成了子问题：在$a[0:k_f-1]$和$b[k_c:n-1]$的并集中寻找第$k-k_c=k_f$小的元素。</p>
</li>
<li><p>若$a[k_f-1]&lt;b[k_c-1]$，说明了$a[k_f-1]&lt;b[0:k_c-1]$共$k_c$个元素，可以推出比$a[k_f-1]$还要小的元素最多只可能有$k-2$个：$b[0:k_c-2]$和$a[0:k_f-2]$。因此，第$k$小的元素一定$&gt;a[k_f-1]$。由于$b[k_c-1]$是$a[0:k_f-1]$和$b[0:k_c-1]$中最大的，且这两个区间共有$k$个元素，故第$k$小的元素一定$\leq b[k_c-1]$。</p>
<p>综上所述，原问题被缩减成了子问题：在$a[k_f:m-1]$和$b[0:k_c-1]$的并集中寻找第$k-k_f=k_c$小的元素。</p>
</li>
<li><p>若$a[k_f-1]=b[k_c-1]$，由于$k_f+k_c=k$，且$a[k_f-1]$和$b[k_c-1]$是$a[0:k_f-1]$和$b[0:k_c-1]$中最大的，所以第$k$小的元素就是$a[k_f-1]$或$b[k_c-1]$。</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_from_two_sorted_array</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> la, <span class="keyword">int</span> ra, <span class="keyword">int</span>* b, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> na = ra - la;</span><br><span class="line">	<span class="keyword">int</span> nb = rb - lb;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(na &gt; <span class="number">0</span> ? a[la] : INT_MAX, nb &gt; <span class="number">0</span> ? b[lb] : INT_MAX);</span><br><span class="line">	<span class="keyword">int</span> kf = k / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> kc = k % <span class="number">2</span> == <span class="number">0</span> ? k / <span class="number">2</span> : (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> am = la + kf - <span class="number">1</span> &lt; ra ? a[la + kf - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> bm = lb + kc - <span class="number">1</span> &lt; rb ? b[lb + kc - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">	<span class="keyword">if</span> (am == bm) <span class="keyword">return</span> am;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (am &gt; bm) <span class="keyword">return</span> <span class="built_in">select_from_two_sorted_array</span>(a, la, <span class="built_in">min</span>(la + kf, ra), b, <span class="built_in">min</span>(lb + kc, rb), rb, kf);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">select_from_two_sorted_array</span>(a, <span class="built_in">min</span>(la + kf, ra), ra, b, lb, <span class="built_in">min</span>(lb + kc, rb), kc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：每次递归$k$都变为原来的一半，故复杂度为$O(\log k)$，与数组长度无关。</p>
<h2 id="9-数组的主元"><a href="#9-数组的主元" class="headerlink" title="9. 数组的主元"></a>9. 数组的主元</h2><p>数组$A$中有$n$个元素，每个元素都是复杂类型，无法比较大小，但是能够判断两个元素是否相同。若$A$中超过一半的元素都相同，我们称这个元素为主元。设计一个算法，判断给定数组中是否存在主元，若有，则找出主元。</p>
<p>第一种思路，采用分治法，把$A$平均分成$A_1$和$A_2$，递归寻找出$A_1$和$A_2$的主元$v_1$和$v_2$。若$A$存在主元，则主元一定是$v_1$和$v_2$，再加以验证一下即可。具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">major_element</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>* major)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r - l == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">		*major = a[l];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span>* major1 = <span class="keyword">new</span> <span class="keyword">int</span>; </span><br><span class="line">	<span class="keyword">int</span>* major2 = <span class="keyword">new</span> <span class="keyword">int</span>; </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">major_element</span>(a, l, m, major1)) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == *major1) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">			*major = *major1; </span><br><span class="line">			<span class="keyword">delete</span> major1; <span class="keyword">delete</span> major2; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">major_element</span>(a, m, r, major2)) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == *major2) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">			*major = *major2; </span><br><span class="line">			<span class="keyword">delete</span> major1; <span class="keyword">delete</span> major2; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列出如下的递归表达式：</p>
<p>$$<br>T(n)=2T(n/2)+O(n)<br>$$</p>
<p>复杂度为$O(n\log n)$。</p>
<p>第二种思路：</p>
<ol>
<li>若$n$为偶数，则把数组中的元素两两配对，两个元素相同，就丢弃任意一个；两个元素不同，就全部丢弃。</li>
<li>若$n$为奇数，则取出一个元素验证其是否是主元，若不是，剩余部分当作$n$为偶数的情况处理。每一轮，数组的元素个数至少变为前一轮的一半，最终剩下的元素将为主元。</li>
</ol>
<p>$Proof$：</p>
<p>若$n$为偶数，假设$v$为配对删除操作后剩余$n/2$元素数组的主元，则$v$出现的次数$\geq\lfloor n/4\rfloor+1$，根据配对法则，$v$在$n$元素数组中出现的次数$\geq 2\lfloor n/4\rfloor+2 &gt; 2(n/4-1)+2=n/2$，说明$v$也是原数组的主元。</p>
<p>若$n$为奇数，假设$v$为配对删除操作后剩余$n-1$素数组的主元，则$v$出现的次数$\geq(n-1)/2+1=n/2+1/2&gt;n/2$，说明$v$也是原数组的主元。▮ </p>
<p>具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">major_element2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* major)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		*major = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span>* aa = <span class="keyword">new</span> <span class="keyword">int</span>[n / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>]) aa[k++] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> res = <span class="built_in">major_element2</span>(aa, k, major);</span><br><span class="line">		<span class="keyword">delete</span>[] aa;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == a[n<span class="number">-1</span>]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= n / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">			*major = a[n<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">major_element2</span>(a, n - <span class="number">1</span>, major);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归表达式：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>T(n)=<br>&amp; = \frac{1}{2}[T(n/2)+O(n)]+\frac{1}{2}[T(n-1)+O(n)] \\ &amp;= \frac{1}{2}[T(n/2)+O(n)]+\frac{1}{2}[T(n/2)+O(n)] \\ &amp;= T(n/2)+O(n)<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>复杂度为$O(n)$。</p>
<h2 id="10-Modular-Fourier-Transform"><a href="#10-Modular-Fourier-Transform" class="headerlink" title="10. Modular Fourier Transform"></a>10. Modular Fourier Transform</h2><p>普通的傅里叶变换涉及复数的运算，较为繁琐，而且如果多项式的系数非常大，也不便运算，故我们寻找一种模运算体系下的傅里叶变换。假设$n=6$，原来$\omega_6=e^{2\pi i/6}$，现在令$\omega_6=3$，可以发现：</p>
<p>$$<br>1+\omega_6^1+\omega_6^2+\omega_6^3+\omega_6^4+\omega_6^5\equiv 0 (\mod 7)<br>$$</p>
<p>上述性质与$n$个复数根满足的性质相同。下面我们类比普通的FT，构造模运算下的系数矩阵：</p>
<p>$$<br>M_6(\omega)<br>\equiv<br>\begin{equation}<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 3 &amp; 2 &amp; 6 &amp; 4 &amp; 5 \\ 1 &amp; 2 &amp; 4 &amp; 1 &amp; 2 &amp; 4 \\ 1 &amp; 6 &amp; 1 &amp; 1 &amp; 6 &amp; 1 \\ 1 &amp; 4 &amp; 2 &amp; 1 &amp; 4 &amp; 2 \\ 1 &amp; 5 &amp; 4 &amp; 6 &amp; 2 &amp; 3<br>\end{bmatrix}<br>\end{equation}<br>(\mod 7)<br>$$</p>
<p>$\frac{1}{6}\mod 7$的逆元为6，对原矩阵中每个元素也求逆元，则该矩阵的逆矩阵为：</p>
<p>$$<br>M_6(\omega)^{-1}<br>\equiv<br>\frac{1}{6}M_6(\omega^{-1})<br>\equiv<br>6\cdot<br>\begin{equation}<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 5 &amp; 4 &amp; 6 &amp; 2 &amp; 3\\ 1 &amp; 4 &amp; 2 &amp; 1 &amp; 4 &amp; 2 \\ 1 &amp; 6 &amp; 1 &amp; 1 &amp; 6 &amp; 1 \\ 1 &amp; 2 &amp; 4 &amp; 1 &amp; 2 &amp; 4 \\ 1 &amp; 3 &amp; 2 &amp; 6 &amp; 4 &amp; 5<br>\end{bmatrix}<br>\end{equation}<br>(\mod 7)<br>$$</p>
<p>现在使用上述的FT modulo 7对多项式$A(x)=x^2+x+1$和$B(x)=x^3+2x-1$做乘法，向量$\mathbb{a}\equiv(1,1,1,0,0,0) (\mod 7)$，向量$\mathbb{b}\equiv(-1,2,0,1,0,0)\equiv(6,2,0,1,0,0) (\mod 7)$。对两个向量做傅里叶变换，$M_6(\omega)\mathbb{a}\equiv (3,6,0,1,0,3) (\mod 7)$，$M_6(\omega)\mathbb{b}\equiv (2,4,4,3,1,1) (\mod 7)$，然后做点乘得到$\mathbb{c}\equiv (6,3,0,3,0,3)(\mod 7)$，最后做逆变换得到相乘结果：$M_6(\omega)^{-1}\mathbb{c}\equiv (-1,1,1,3,1,1) (\mod 7)$。</p>
<p>由此看来，并不是一定要以复数根作为傅里叶变换的基底，只要满足一定的条件，实数也可以作为基底。</p>
<h2 id="11-Revisit-gcd"><a href="#11-Revisit-gcd" class="headerlink" title="11. Revisit gcd"></a>11. Revisit gcd</h2><p>之前使用欧几里得算法：$gcd(a,b)=gcd(b,a\mod b)$来计算最大公因数，现在使用分治法，假设$a\geq b$：</p>
<p>$$<br>\begin{equation}<br>gcd(a,b)=<br>\begin{cases}<br> 2gcd(a/2,b/2), &amp; a,b都是偶数 \\  gcd(a/2,b), &amp; a为偶数,b为奇数 \\  gcd((a-b)/2,b), &amp; a,b都是奇数<br>\end{cases}<br>\end{equation}<br>$$</p>
<p>$Proof$：</p>
<p>若$a,b$都是偶数，设$gcd(a,b)=d,a=da’,b=db’$，则$gcd(a’,b’)=1$。由于$a,b$都是偶数，说明$2$整除$d$，故$a=(d/2)a’,b=(d/2)b’$，则$gcd(a/2,b/2)=d/2$。</p>
<p>若$a$为偶数，$b$为奇数，则$gcd(a,b)=d$一定是奇数，$d$整除$a$的话，$d$也一定能整除$a/2$。（$d$没有因子2）</p>
<p>若$a,b$都是奇数，使用结论：$gcd(a,b)=gcd(a-b,b)$，再使用情况2的结论。▮</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_divide_conquer</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">gcd_divide_conquer</span>(a / <span class="number">2</span>, b / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd_divide_conquer</span>(a / <span class="number">2</span>, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">gcd_divide_conquer</span>(a, b / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> a &gt;= b ? <span class="built_in">gcd_divide_conquer</span>((a - b) / <span class="number">2</span>, b) : <span class="built_in">gcd_divide_conquer</span>((b - a) / <span class="number">2</span>, a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：假设$a,b$都是$n-bit$，算法每次至少将$a,b$中的一个减为一半，所有最多递归$O(n)$次，每次的移位、减法操作复杂度为$O(n)$，故总复杂度为$O(n^2)$。这比欧几里得算法$O(n^3)$要快。</p>
<h2 id="12-最近的点对"><a href="#12-最近的点对" class="headerlink" title="12. 最近的点对"></a>12. 最近的点对</h2><p>平面中有$n$个点：{ $p_1=(x_1,y_1),p_2=(x_2,y_2),\cdots,p_n=(x_n,y_n)$ }，如何在$O(n\log n)$内找出距离最近的点对？</p>
<p>首先找到所有点的横坐标的中位数$x$，以中位数$x$为界限，把点分成左右两组：$L$和$R$。</p>
<p>然后递归地在$L$和$R$中寻找最近的点对：$(p_L,q_L)\in L,(p_R,q_R)\in R$，最近的距离分别为$d_L$和$d_R$，令$d=\min(d_L,d_R)$。</p>
<p>最近的点对有可能是一个点在$L$中，另一个在$R$中，所以下面要求出这种情况下最近的点对。把$x_i\in[x-d,x+d]$的点单独分为一组：$M$，则易知这种情况下最近的点对一定在$M$中。我们可以遍历$M$中所有的点对（$O(n^2)$），计算出两两之间的距离，得出最近点对，但是其实不需要遍历全部的点对，下面是证明。</p>
<p>假设现在有一个$d\times d$的区域，那么里面最多包含$L$中的四个点。$Proof$：若该区域包含5个$L$中的点，把该区域分成四个$d/2\times d/2$的小区域，其中一个小区域一定包含2个$L$中的点，它们之间的距离最大为$d/\sqrt{2}&lt;d$，与最近的点对距离为$d$矛盾，故结论成立。▮ 同理，一个$d\times d$的区域里面最多包含$R$中的四个点。</p>
<p>下面对$M$中的点按纵坐标的值排序，按纵坐标值从小到大遍历$M$中的一个点$(x_i,y_i)$，若$M$中存在另一个点使得它们两点间的距离小于$d$，那个点一定在$(x-d,y_i),(x-d,y_i+d),(x+d,y_i),(x+d,y_i+d)$组成的长方形区域中。该区域与$L$的交集最大为$d\times d$，与$R$的交集最大也为$d\times d$。根据上述推论，长方形区域中最多有8个点。</p>
<p>因此，对$M$中的点按纵坐标的值排序后（$O(n\log n)$），我们只需要遍历$M$中所有的点，计算出每个点与其后面的连续7个点间的距离（$O(1)$），得出最近点对即可。</p>
<p>列出递归表达式：</p>
<p>$$<br>T(n)=2T(n/2)+O(n\log n)<br>$$</p>
<p>复杂度为$O(n\log^2 n)$。优化一下，我们在一开始就对所有点按纵坐标排序，而不是每次递归中排序：</p>
<p>$$<br>T(n)=2T(n/2)+O(n)<br>$$</p>
<p>复杂度为$O(n\log n)$，一开始就排序的复杂度恰好也是$O(n\log n)$，故总复杂度为$O(n\log n)$。</p>
<h2 id="13-分位数（Quantiles）"><a href="#13-分位数（Quantiles）" class="headerlink" title="13. 分位数（Quantiles）"></a>13. 分位数（Quantiles）</h2><p>一组数据的$k$分位数是指，将数据排序后，能把数据分成数量接近的$k$个组的$k-1$个分割点。比如，数组$A$的二分位数就是中位数。设计一个算法求出数组$A$的所有$k$分位数。</p>
<p>第一种思路，使用快速选择算法$k-1$次，第$j$次选出第$jn/k$小的元素，复杂度为$O(nk)$。</p>
<p>第二种思路，使用分治法。</p>
<ol>
<li>若$k$为偶数，使用in-place快速选择算法找出中位数，此时中位数不小于它前面的元素，不大于它后面的元素。然后以中位数为界，递归地找出左边数列（前$(n+1)/2$个元素）的$k/2$分位数和右边数列（剩余元素）的$k/2$分位数，最后合并左边的$k/2-1$个$k/2$分位数，中位数，右边的$k/2-1$个$k/2$分位数。</li>
<li>若$k$为奇数，使用in-place快速选择算法找出第$n/k$大的数，然后递归地找出它后面元素的$k-2$个$k-1$分位数，最后合并第$n/k$大的数和$k-2$个$k-1$分位数。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">quickselect</span>(a, l, r, ((r - l) + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// k &gt; 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">quantile</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = r - l;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">		res[<span class="number">0</span>] = <span class="built_in">median</span>(a, l, r);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="built_in">median</span>(a, l, r);</span><br><span class="line">		<span class="keyword">int</span>* left = <span class="built_in">quantile</span>(a, l, l + (n + <span class="number">1</span>) / <span class="number">2</span>, k / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">int</span>* right = <span class="built_in">quantile</span>(a, l + (n + <span class="number">1</span>) / <span class="number">2</span>, r, k / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[k - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; k / <span class="number">2</span> - <span class="number">1</span>; ++i) res[i] = left[i];</span><br><span class="line">		res[i++] = m;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; k - <span class="number">1</span>; ++i) res[i] = right[i-k/<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> q = <span class="built_in">quickselect</span>(a, l, r, n / k);</span><br><span class="line">		<span class="keyword">int</span>* right = <span class="built_in">quantile</span>(a, l + n / k, r, k - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[k - <span class="number">1</span>];</span><br><span class="line">		res[<span class="number">0</span>] = q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k - <span class="number">1</span>; ++i) res[i] = right[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归表达式：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>T(k)<br>&amp; = \frac{1}{2}[T(k/2)+O(n)]+\frac{1}{2}[T(k-1)+O(n)] \\ &amp;= \frac{1}{2}[T(k/2)+O(n)]+\frac{1}{2}[T(k/2)+O(n)] \\ &amp;= T(k/2)+O(n)<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>复杂度为$O(n\log k)$。</p>
<h2 id="14-Revisit-FFT-base-3"><a href="#14-Revisit-FFT-base-3" class="headerlink" title="14. Revisit FFT (base=3)"></a>14. Revisit FFT (base=3)</h2><p>在进行FFT时，若向量$\mathbb{a}$的长度不是2的幂，而是3的幂，我们也可以使用基为3的快速傅里叶变换。</p>
<p>假设$A(x)=a_0+a_1x+a_2x^2+\cdots,a_8x^8$，令$\omega_9$为主8次复数根，把多项式系数下标按照$\mod 3$余数的不同，分成三组$A(x)=A_0(x^3)+xA_1(x^3)+x^2A_2(x^3)$，则：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>A(w_9^k)<br>&amp;= A_0(w_3^{k})+w_9^kA_1(w_3^{k})+w_9^{2k}A_2(w_3^{k})<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>A(w_9^{k+3})<br>&amp; = A_0(w_3^{k})+e^{2\pi i/3}\cdot w_9^kA_1(w_3^{k})+e^{-2\pi i/3}\cdot w_9^{2k}A_2(w_3^{k})<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>A(w_9^{k+6})<br>&amp; = A_0(w_3^{k})+e^{-2\pi i/3}\cdot w_9^kA_1(w_3^{k})+e^{2\pi i/3}\cdot w_9^{2k}A_2(w_3^{k})<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>其中$k=0,1,2$。根据上述递推表达式，可以模仿基为2的FFT算法，进行基为3的FFT。</p>
<h2 id="15-最坏情况为-O-n-的快速选择算法"><a href="#15-最坏情况为-O-n-的快速选择算法" class="headerlink" title="15. 最坏情况为$O(n)$的快速选择算法"></a>15. 最坏情况为$O(n)$的快速选择算法</h2><p>在之前的快速选择算法中，即使我们随机选取主元，最坏情况下的复杂度仍为$O(n^2)$，下面采取一种”Median of Medians”的方法进行优化。</p>
<p>这个方法仅仅是改变了选取主元的方式，每次需要选取主元时：</p>
<ol>
<li>将数组平均分成$\lceil n/5 \rceil$个子数组，每个数组5个元素，最后一个数组可能不足5个元素。</li>
<li>计算出$\lceil n/5 \rceil$个子数组中每个数组的中位数，生成”中位数”数组。（固定元素数目的数组中寻找中位数$O(1)$）</li>
<li>选择”中位数”数组的中位数作为主元。</li>
</ol>
<p>令$p$为选取到的主元，$p$为”中位数”数组的中位数，不包括$p$所在的子数组和最后不足5元素的子数组，则至少有$\lceil\frac{1}{2}\lceil n/5\rceil \rceil-2$个子数组的中位数$m$满足$p\geq m$。由于$m$又是子数组的中位数，子数组有5个元素，所以$m\geq$3个子数组中的元素。综上所述，至少有$\lceil\frac{1}{2}\lceil n/5\rceil \rceil-2\geq3n/10-6$个元素$x$满足$p\geq x$；同理可证，至少有$3n/10-6$个元素$x$满足$p\leq x$。</p>
<p>根据上面的结论，令$p$作为主元，每次<code>split()</code>操作，最多只能把数组缩减到$7n/10+6$。列出最坏情况下的递归表达式：</p>
<p>$$<br>T(n)\leq T(\lceil n/5 \rceil)+T(7n/10+6)+O(n)<br>$$</p>
<p>使用替换法，假设$T(n)\leq cn$，则：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>T(n)<br>&amp; \leq T(\lceil n/5 \rceil)+T(7n/10+6)+dn \\ &amp;\leq cn/5+c+7cn/10+6c+dn \\ &amp;= (\frac{9}{10}c+d)n+7c<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>只要选择这样的$c$：$cn\geq (\frac{9}{10}c+d)n+7c$，就可以满足假设。</p>
<p>故最坏情况的复杂度是$O(n)$。</p>
<h2 id="16-3-Sum问题"><a href="#16-3-Sum问题" class="headerlink" title="16. 3-Sum问题"></a>16. 3-Sum问题</h2><p>在计算几何学中，很多问题都与3-Sum问题有关。给定数组$A[0,1,\cdots,n-1]$，设计算法来判断是否存在三个索引$i,j,k$使：</p>
<p>$$<br>A[i]+A[j]+A[k]=n<br>$$</p>
<p>只需要判断是否存在，不用返回具体的组合。很容易想到$O(n^2)$的算法，而且目前并没有找到比$O(n^2)$更快的算法。</p>
<p>但是如果施加一个约束：$0\leq A[k] \leq n,k=0,1,\cdots,n-1$，复杂度就可以被优化到$O(n\log n)$。</p>
<p>我们构造出下面的多项式：</p>
<p>$$<br>p(x)=x^{A[0]}+x^{A[1]}+\cdots+x^{A[n-1]}=\sum_{i=0}^{n-1}x^{A[i]}<br>$$</p>
<p>这个多项式的次数最大只可能是$n$。令$q(x)=p(x)^3$，则：</p>
<p>$$<br>q(x)=(\sum_{i=0}^{n-1}x^{A[i]})(\sum_{j=0}^{n-1}x^{A[j]})(\sum_{k=0}^{n-1}x^{A[k]})=\sum_{0\leq i,j,k&lt;n}x^{A[i]+A[j]+A[k]}<br>$$</p>
<p>我们使用FFT计算出$q(x)$，$q(x)$的$x^n$前面的系数就是满足条件的$(i,j,k)$的组数，复杂度为$O(n\log n)$。</p>
<p>若没有$0\leq A[k] \leq n,k=0,1,\cdots,n-1$的约束，使用这个方法效率会很低，因为数组的元素可能很大，导致多项式乘法耗时太久。</p>
<p>Quick Link: <a href="https://2horse9sun.github.io/2021/12/19/2021-12-19-algorithms-notes-overview/">算法笔记整理</a></p>
</div><hr style="height:1px;margin:1rem 0"></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/13/2022-01-13-algorithms-notes-chap2-3-fft/"><span class="level-item">chap 2-3 分治算法-多项式与快速傅里叶变换</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Felix Feng"></figure><p class="title is-size-4 is-block" style="font-weight: bold">Felix Feng</p><p class="is-size-6 is-block" style="margin-top: 1rem">jsjhfx@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Posts</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Tags</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/2horse9sun" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/2horse9sun"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="is-4-tablet is-4-desktop is-3-widescreen  is-sticky" style="margin-top: 1.5rem"> <div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-满二叉树的数量"><span class="level-left"><span class="level-item">1. 满二叉树的数量</span></span></a></li><li><a class="level is-mobile" href="#2-二分查找模板"><span class="level-left"><span class="level-item">2. 二分查找模板</span></span></a></li><li><a class="level is-mobile" href="#3-无限数列中的搜索"><span class="level-left"><span class="level-item">3. 无限数列中的搜索</span></span></a></li><li><a class="level is-mobile" href="#4-搜索复杂度下界"><span class="level-left"><span class="level-item">4. 搜索复杂度下界</span></span></a></li><li><a class="level is-mobile" href="#5-k-way-merge"><span class="level-left"><span class="level-item">5. k-way merge</span></span></a></li><li><a class="level is-mobile" href="#6-线性时间排序"><span class="level-left"><span class="level-item">6. 线性时间排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-计数排序（counting-sort）"><span class="level-left"><span class="level-item">6.1 计数排序（counting sort）</span></span></a></li><li><a class="level is-mobile" href="#6-2-基数排序（radix-sort）"><span class="level-left"><span class="level-item">6.2 基数排序（radix sort）</span></span></a></li><li><a class="level is-mobile" href="#6-3-桶排序（bucket-sort）"><span class="level-left"><span class="level-item">6.3 桶排序（bucket sort）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-中位数和平均数"><span class="level-left"><span class="level-item">7. 中位数和平均数</span></span></a></li><li><a class="level is-mobile" href="#8-两个有序数组的-k-th-smallest-element"><span class="level-left"><span class="level-item">8. 两个有序数组的$k$th smallest element</span></span></a></li><li><a class="level is-mobile" href="#9-数组的主元"><span class="level-left"><span class="level-item">9. 数组的主元</span></span></a></li><li><a class="level is-mobile" href="#10-Modular-Fourier-Transform"><span class="level-left"><span class="level-item">10. Modular Fourier Transform</span></span></a></li><li><a class="level is-mobile" href="#11-Revisit-gcd"><span class="level-left"><span class="level-item">11. Revisit gcd</span></span></a></li><li><a class="level is-mobile" href="#12-最近的点对"><span class="level-left"><span class="level-item">12. 最近的点对</span></span></a></li><li><a class="level is-mobile" href="#13-分位数（Quantiles）"><span class="level-left"><span class="level-item">13. 分位数（Quantiles）</span></span></a></li><li><a class="level is-mobile" href="#14-Revisit-FFT-base-3"><span class="level-left"><span class="level-item">14. Revisit FFT (base=3)</span></span></a></li><li><a class="level is-mobile" href="#15-最坏情况为-O-n-的快速选择算法"><span class="level-left"><span class="level-item">15. 最坏情况为$O(n)$的快速选择算法</span></span></a></li><li><a class="level is-mobile" href="#16-3-Sum问题"><span class="level-left"><span class="level-item">16. 3-Sum问题</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithms-Notes/"><span class="tag">Algorithms-Notes</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cryptography/"><span class="tag">Cryptography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Divide-and-Conquer/"><span class="tag">Divide and Conquer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FFT/"><span class="tag">FFT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hashing/"><span class="tag">Hashing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Internet/"><span class="tag">Internet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Number-Theory/"><span class="tag">Number Theory</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sorting/"><span class="tag">Sorting</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Statistics/"><span class="tag">Statistics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-APP/"><span class="tag">Web APP</span><span class="tag">1</span></a></div></div></div></div></div> </div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a><p class="is-size-7"><span>&copy; 2022 Felix Feng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>