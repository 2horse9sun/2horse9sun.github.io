<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Felix Feng&#039;s Zone</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XU FENG&#039;S ZONE"><meta name="msapplication-TileImage" content="/images/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XU FENG&#039;S ZONE"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Felix Feng&#039;s Zone"><meta property="og:url" content="https://2horse9sun.github.io/"><meta property="og:site_name" content="Felix Feng&#039;s Zone"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://2horse9sun.github.io/img/og_image.png"><meta property="article:author" content="Felix Feng"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://2horse9sun.github.io"},"headline":"Felix Feng's Zone","image":["https://2horse9sun.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Felix Feng"},"publisher":{"@type":"Organization","name":"Felix Feng's Zone","logo":{"@type":"ImageObject","url":"https://2horse9sun.github.io/images/site-logo.png"}},"description":""}</script><link rel="icon" href="/images/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6295a3485ca71319f7c2bb6050180382";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Blog</a><a class="navbar-item" href="/categories/Note">Note</a><a class="navbar-item" href="/categories/Project">Project</a><a class="navbar-item" href="/categories/Essay">Essay</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2023/09/01/2023-09-01-notes-learncpp/"><img class="fill" src="/images/banners/learncpp.png" alt="Learncpp学习笔记"></a></div><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold"><a class="link-muted" href="/2023/09/01/2023-09-01-notes-learncpp/">Learncpp学习笔记</a></h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2023-08-31T21:00:00.000Z" title="2023/9/1 00:00:00">2023-09-01</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Note/">Note</a></span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style="color: grey; font-weight: normal; font-style: italic"><h2 id="1-C-编译与链接"><a href="#1-C-编译与链接" class="headerlink" title="1. C++编译与链接"></a>1. C++编译与链接</h2><h3 id="1-1-机器-汇编-高级语言"><a href="#1-1-机器-汇编-高级语言" class="headerlink" title="1.1 机器/汇编/高级语言"></a>1.1 机器/汇编/高级语言</h3><p>机器码(machine code, instruction set)：速度最快，可读性较差，不同CPU有不同的指令集，程序不具有移植性(portable)。</p>
<p>汇编语言(assembly language)：速度较快，有一定可读性，需要用汇编器(assembler)将汇编语言翻译成机器码。程序移植性较差，通常情况下为一个CPU写的汇编，在另一种CPU上无法运行，因为指令集不同。</p>
<p>高级语言(high-level language)：目的是为了解决可读性和可移植性问题。大多数编程语言(e.g. C, C++)都是高级语言。</p>
<h3 id="1-2-编译器和解释器"><a href="#1-2-编译器和解释器" class="headerlink" title="1.2 编译器和解释器"></a>1.2 编译器和解释器</h3><p>高级语言需要被翻译成机器码，通常有两种方式：编译(compiling)和解释(interpreting)。</p>
<p>编译器(compiler)：根据源代码生成可执行文件(executable)，只需编译一次。编译器可能会对代码做不同程度的优化(optimization)。程序修改后，需要重新编译相关文件。</p>
<img src="/images/posts/compiling_process.png" alt="compiling_process" style="zoom:80%;" />

<p>解释器(interpreter)：直接根据源代码执行指令，不需要生成可执行文件。程序每次运行，都需要执行解释过程。</p>
<img src="/images/posts/interpretation_process.png" alt="interpretation_process" style="zoom:80%;" />

<p>编译型语言：C, C++, Pascal</p>
<p>解释型语言：脚本语言，如Python, Javascript</p>
<p>混合类型：Java需要预先把代码编译成虚拟机指令，然后再运行这些虚拟机指令</p>
<p>编译型语言和解释型语言的本质都是解释执行的，编译型和解释型的语言之所以可以说相同，是因为这些语言从文本形式的源代码到最终产生的结果，所经历的过程是一样的。根本区别是运行时，解释型需要将程序解释成机器码来运行，并没有保存机器码，是在运行过程中进行。而编译型在运行之前就已经让编译器给程序编译成机器码了。</p>
<p>编译器如何解决可移植性问题？对于不同的平台，使用适配的编译器来生成可执行文件。但是，很多platform-specific和compiler-specific的特性降低了可移植性。</p>
<img src="/images/posts/compiler_for_different_hardware.png" alt="compiler_for_different_hardware" style="zoom:80%;" />

<h3 id="1-3-C-编译链接过程"><a href="#1-3-C-编译链接过程" class="headerlink" title="1.3 C++编译链接过程"></a>1.3 C++编译链接过程</h3><img src="/images/posts/c++_compile_step.png" alt="c++_compile_step" style="zoom:80%;" />

<p>C++编译过程主要分为三步：</p>
<ol>
<li>预处理(preprocessing)：展开预编译指令(preprocessor directives)，比如<code>#include</code>和<code>#define</code>。</li>
<li>编译(compilation)：生成对象文件(object file, .o, .obj)</li>
<li>链接(linking)：链接生成的对象文件以及相关库(library)，生成库文件或可执行文件。</li>
</ol>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理阶段，几种常见的预编译指令：</p>
<ol>
<li><code>#include</code>：被替换成对应的头文件，递归进行展开</li>
<li><code>#define</code>：宏展开(macro expansion)</li>
<li><code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>：比如针对不同平台使用不同代码</li>
</ol>
<p>此阶段还会删除注释，可能添加一些标识信息。预处理后的文件称为translation unit，是下一步编译的基本单元。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><img src="/images/posts/object_file.png" alt="object_file" style="zoom:80%;" />

<p>编译阶段，编译器首先将每个源文件单独编译成汇编代码(assembly code，.s)，然后汇编器(assembler)会将汇编代码转换成机器码，即对象文件。对象文件可以引用(reference)未定义(define)的符号(symbol)，前提是该符号已经被提前声明(declare)，则编译器不会报错。不同源文件可以分别编译，改动一个文件，只需要重新编译与它相关的源文件。</p>
<p>这一阶段常见的错误是语法错误。</p>
<p>对于编译好的对象文件，可以使用archiving捆绑生成(bundled)静态库(static lib, .lib, .a)。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><img src="/images/posts/linker.png" alt="linker" style="zoom:80%;" />

<p>链接器(linker)将链接所有的对象文件，建立映射关系并且合并符号表，符号表进行符号解析，即寻找被引用的未定义符号的正确地址，这些符号可能在别的对象文件或库中被定义。链接完成后，可以生成可执行文件或或动态库(dynamic lib, DLL, .so)。</p>
<p>这一阶段常见的错误是符号未定义或重复定义。</p>
<p>为什么要把编译和链接分开？一个目的是为了支持条件编译(conditional compilation)：如果某个源文件被更改，只需重新编译那一个文件，其他对象文件不受影响。另一个目的是为了支持预编译代码(pre-compiled code)，只需链接相关的对象文件即可。</p>
<h3 id="1-4-静态链接和动态链接"><a href="#1-4-静态链接和动态链接" class="headerlink" title="1.4 静态链接和动态链接"></a>1.4 静态链接和动态链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Phase     Static                    Dynamic</span><br><span class="line">--------  ----------------------    ------------------------</span><br><span class="line">          +---------+               +---------+</span><br><span class="line">          | main.c  |               | main.c  |</span><br><span class="line">          +---------+               +---------+</span><br><span class="line">Compile........|.........................|...................</span><br><span class="line">          +---------+ +---------+   +---------+ +--------+</span><br><span class="line">          | main.o  | | crtlib  |   | main.o  | | crtimp |</span><br><span class="line">          +---------+ +---------+   +---------+ +--------+</span><br><span class="line">Link...........|..........|..............|...........|.......</span><br><span class="line">               |          |              +-----------+</span><br><span class="line">               |          |              |</span><br><span class="line">          +---------+     |         +---------+ +--------+</span><br><span class="line">          |  main   |-----+         |  main   | | crtdll |</span><br><span class="line">          +---------+               +---------+ +--------+</span><br><span class="line">Load/Run.......|.........................|..........|........</span><br><span class="line">          +---------+               +---------+     |</span><br><span class="line">          | main <span class="keyword">in</span> |               | main <span class="keyword">in</span> |-----+</span><br><span class="line">          | memory  |               | memory  |</span><br><span class="line">          +---------+               +---------+</span><br></pre></td></tr></table></figure>

<p>静态库和静态链接：静态库包含了运行该库所需的所有依赖(self-contained)。链接阶段时，静态库将被插入到最终的可执行文件中。优点是运行时无额外开销，程序发布的时候不需要的依赖库。缺点是导致可执行性文件较大，而且如果静态库更新，所有可执行文件都要重新编译。</p>
<p>动态库和动态链接：动态库包含了运行该库所需的所有依赖。链接阶段时，在可执行文件运行时被引用(reference)。可执行文件只保存被链接文件的位置，等到程序运行阶段时，再把需要的文件加载到内存中。本质上是一种延迟链接(deferred linking)，有些系统甚至会等到目标函数被调用时，再链接目标文件。插件(plug-in)实现的原理就是动态链接。</p>
<p>动态链接可以减小可执行文件的大小，多个程序可以共享同一段代码，利于代码复用，但是每次运行时链接会有一定的性能损耗。动态链接有利于各个动态库独立的更新与开发，但是如果更新版本与可执行文件不兼容，则会导致程序出错。</p>
<p>DLL hell：程序A和B同时使用DLL1.0，然后B更新动态库为DLL2.0，但是DLL不是后向兼容的，导致了A无法正常运行。于是A重新安装DLL1.0，这又导致了B无法运行。</p>
<h3 id="1-5-预编译头文件"><a href="#1-5-预编译头文件" class="headerlink" title="1.5 预编译头文件"></a>1.5 预编译头文件</h3><p>预编译头文件(precompiled header, .pch)解决的问题：在大型项目中，一些头文件可能被多个源文件包括，造成重复编译，非常费时。预编译头文件是预先编译好的中间文件，被源文件包括后就无需再次编译了，能够缩短编译时间。如果某个头文件经常被修改，就不适合进行预编译。所以最理想的预编译头文件通常是一些标准库或第三方库文件。</p>
<h3 id="1-6-Include-guards"><a href="#1-6-Include-guards" class="headerlink" title="1.6  Include guards"></a>1.6  Include guards</h3><p>Include guards：防止一个头文件在编译同一个源文件时被多次include，但是不能避免一个头文件被不同的源文件include。通常有两种方式：<code>#ifndef</code>和<code>#pragma once</code>。</p>
<p><code>#ifndef</code>采用宏的方式，防止同一个头文件被多次include。难点在于整个项目中不能出现相同的宏。</p>
<p><code>#pragma once</code>是大多数编译器具有的一种扩展功能(不属于C++标准)，把它放置在头文件开头后，如果编译器第一次遇到这个文件，将会做一个标记且正常编译，后面如果再遇到相同文件就直接跳过。难点在于不同编译器对于相同文件的定义有所不同，可能会造成跨平台编译的不一致。</p>
<p>两种方式性能差异不大。</p>
<h3 id="1-7-声明和定义"><a href="#1-7-声明和定义" class="headerlink" title="1.7 声明和定义"></a>1.7 声明和定义</h3><p>使用前向声明(forward declaration)的主要目的：</p>
<ol>
<li>缩短编译时间。很多时候，在头文件中，只需要提前声明其他头文件中的某几个数据结构即可正常编译。如果每次都include一整个头文件，那么所有涉及到的头文件都将在源文件中被展开并编译，增加了编译时间。</li>
<li>避免循环引用(cyclic/circular references)。经常会出现以下情景：两个类都含有指向对方的指针，此时只能使用前向声明而无法同时include对方的头文件。</li>
<li>可以用任意顺序定义(define)函数。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Example</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Function forward declaration</td>
<td align="left">void foo(int x);</td>
<td align="left">Prototype only, no function body</td>
</tr>
<tr>
<td align="left">Non-constant variable forward declaration</td>
<td align="left">extern int g_x;</td>
<td align="left">Must be uninitialized</td>
</tr>
<tr>
<td align="left">Const variable forward declaration</td>
<td align="left">extern const int g_x;</td>
<td align="left">Must be uninitialized</td>
</tr>
<tr>
<td align="left">Constexpr variable forward declaration</td>
<td align="left">extern constexpr int g_x;</td>
<td align="left">Not allowed, constexpr cannot be forward declared</td>
</tr>
</tbody></table>
<p>一个定义原则(one definition rule)：</p>
<ol>
<li>同一个文件中，每个函数、变量、类型和模板只能有一个定义</li>
<li>整个程序中，每个变量和常规的函数只能有一个定义</li>
<li>整个程序中，类型、模板、内联函数和内联变量可以有多个相同的定义</li>
</ol>
<h2 id="2-C-基础知识"><a href="#2-C-基础知识" class="headerlink" title="2. C++基础知识"></a>2. C++基础知识</h2><h3 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h3><p>不同命名空间(namespace)中声明的变量/函数名称可以相同，有利于把相关的变量/函数组织在一起，避免造成名称冲突(name collision)。默认的命名空间是global namespace。</p>
<p>当编写库代码时(给别人使用)，务必要把代码放在自定义的命名空间中(如math::, physics::)，防止用户自己的代码与库代码产生冲突。</p>
<p>匿名命名空间(anonymous namespace)中定义的函数，会把函数的链接变为internal linkage，效果类似于static。</p>
<h3 id="2-2-基本数据类型大小"><a href="#2-2-基本数据类型大小" class="headerlink" title="2.2 基本数据类型大小"></a>2.2 基本数据类型大小</h3><table>
<thead>
<tr>
<th>sizeof()</th>
<th>32-bit system</th>
<th>64-bit system</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td><strong>4</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>long</td>
<td><strong>4</strong></td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>pointer</td>
<td><strong>4</strong></td>
<td><strong>8</strong></td>
</tr>
</tbody></table>
<h3 id="2-3-类型转换"><a href="#2-3-类型转换" class="headerlink" title="2.3 类型转换"></a>2.3 类型转换</h3><p>类型转换(type conversion)分为两类：隐式转换(implicit)和显式(explicit)转换。</p>
<p>隐式转换(automatic type conversion)是编译器自行操作的，当不同类型的变量出现在同一个表达式(expression)时，低精度的类型会被隐式转换成高精度(type promotion)，可能会造成数据丢失或溢出(overflow)，比如<code>long long</code>=&gt;<code>float</code>和<code>int</code>=&gt;<code>unsigned int</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> -&gt; <span class="keyword">char</span> -&gt; <span class="keyword">short</span> <span class="keyword">int</span> -&gt; <span class="keyword">int</span> -&gt; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">unsigned</span> -&gt; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span> -&gt; <span class="keyword">long</span> <span class="keyword">double</span></span><br></pre></td></tr></table></figure>

<p>显式转换(type casting)是用户主动操作的，通常有两种方式：强制转换赋值和强制转换操作符。</p>
<p>强制转换赋值就是在表达式前加上想转换的类型：<code>(type) expression</code>。</p>
<p>强制转换操作符(cast operator)有四种：<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>和<code>reinterpret_cast</code>。</p>
<p><code>static_cast</code>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p>
<ol>
<li>用于基本数据类型的转换。</li>
<li>用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示, cast upwards）是安全的；进行下行转换（基类的指针或引用转换成派生类表示, cast downwards）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。</li>
<li>可以将空指针转化成目标类型的空指针。</li>
<li>可以将任何类型的表达式转化成 void 类型。</li>
</ol>
<p><code>dynamic_cast</code>：动态类型转换是在程序运行时处理的，运行时会进行类型检查，主要用于多态中的下行转换。</p>
<ol>
<li>只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。</li>
<li>在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</li>
<li>在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</li>
</ol>
<p><code>const_cast</code>：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针(pointer to const type)转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p>
<p><code>reinterpret_cast</code>：最危险的强制转换，将一种类型转换为任意一种不同的类型。比如改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</p>
<h3 id="2-4-作用域、生命周期和链接"><a href="#2-4-作用域、生命周期和链接" class="headerlink" title="2.4 作用域、生命周期和链接"></a>2.4 作用域、生命周期和链接</h3><p>作用域(scope)：符号在代码中的某处是否能被访问到。在同一个scope中，符号名称不能相同。</p>
<ol>
<li>block scope：只在所定义的block中可见，如局部变量(local variable)，函数参数</li>
<li>global/file scope：从声明处，直至文件末尾都可见，如全局变量(global variable)，函数</li>
</ol>
<p>生命周期(duration, lifetime)：变量何时创建，何时销毁</p>
<ol>
<li>automatic：被定义时创建，离开创建时所在的block时销毁，如局部变量，函数参数</li>
<li>static：程序开始/变量定义时创建，程序结束时销毁，如全局变量，静态局部变量</li>
<li>dynamic：用户自行创建和销毁，如动态内存分配</li>
</ol>
<p>链接(linkage)：如果其他作用域或文件中存在其他名称相同的声明，是否指代同一个对象</p>
<ol>
<li>no linkage：相同的声明都对应不同的对象，如在不同block中名称相同的局部变量</li>
<li>internal linkage：符号只对一个translation unit可见，即如果两个源文件出现名称相同的符号，则它们被视为不同的对象，如static global、const global、static function、匿名namespace中的函数。有利于避免命名冲突和避免符号被其他文件访问。</li>
<li>external linkage：符号对所在文件可见，且通过前向声明后对其他文件也可见，如function、global、extern const global、inline const global。全局变量的前向声明要加上extern关键字。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Example</th>
<th align="left">Scope</th>
<th align="left">Duration</th>
<th align="left">Linkage</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Local variable</td>
<td align="left">int x;</td>
<td align="left">Block</td>
<td align="left">Automatic</td>
<td align="left">None</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Static local variable</td>
<td align="left">static int s_x;</td>
<td align="left">Block</td>
<td align="left">Static</td>
<td align="left">None</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Dynamic variable</td>
<td align="left">int* x { new int{} };</td>
<td align="left">Block</td>
<td align="left">Dynamic</td>
<td align="left">None</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Function parameter</td>
<td align="left">void foo(int x)</td>
<td align="left">Block</td>
<td align="left">Automatic</td>
<td align="left">None</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">External non-constant global variable</td>
<td align="left">int g_x;</td>
<td align="left">File</td>
<td align="left">Static</td>
<td align="left">External</td>
<td align="left">Initialized or uninitialized</td>
</tr>
<tr>
<td align="left">Internal non-constant global variable</td>
<td align="left">static int g_x;</td>
<td align="left">File</td>
<td align="left">Static</td>
<td align="left">Internal</td>
<td align="left">Initialized or uninitialized</td>
</tr>
<tr>
<td align="left">Internal constant global variable</td>
<td align="left">constexpr int g_x { 1 };</td>
<td align="left">File</td>
<td align="left">Static</td>
<td align="left">Internal</td>
<td align="left">Must be initialized</td>
</tr>
<tr>
<td align="left">External constant global variable</td>
<td align="left">extern const int g_x { 1 };</td>
<td align="left">File</td>
<td align="left">Static</td>
<td align="left">External</td>
<td align="left">Must be initialized</td>
</tr>
<tr>
<td align="left">Inline constant global variable (C++17)</td>
<td align="left">inline constexpr int g_x { 1 };</td>
<td align="left">File</td>
<td align="left">Static</td>
<td align="left">External</td>
<td align="left">Must be initialized</td>
</tr>
</tbody></table>
<h3 id="2-5-全局变量的使用"><a href="#2-5-全局变量的使用" class="headerlink" title="2.5 全局变量的使用"></a>2.5 全局变量的使用</h3><p>避免使用non-const global variable的原因(特例：日志、输入输出流)：</p>
<ol>
<li>全局变量的值可能会被任意其他函数修改，导致调试困难</li>
<li>全局变量的初始化顺序问题。在同一个文件中，全局变量按定义的顺序初始化，在不同文件中，全局变量的初始化顺序不确定，如果不同全局变量的定义之间有依赖关系，会导致出错。</li>
</ol>
<p>解决方法：</p>
<ol>
<li>给全局变量统一加前缀或放到特定命名空间中</li>
<li>把static/const global封装到函数中，使用函数进行初始化和访问，这样其他文件也能访问到全局变量</li>
</ol>
<p>多文件共享const global的方法：</p>
<ol>
<li><p>在头文件<code>constant.h</code>中的自定义命名空间中，定义所需的const global variables，使用时，只需include <code>constant.h</code>。缺点：const global variables的定义将会在很多个源文件中重复，改变一个全局变量的值，将引起所有这些源文件重新编译。</p>
</li>
<li><p>在头文件<code>constant.h</code>中的自定义命名空间中，声明(<code>extern const</code>)所需的const global variables，在源文件<code>constant.cpp</code>中定义(<code>extern const</code>)所需要的全局变量的值。使用时，只需要include <code>constant.h</code>，链接器会找到对应的全局变量的值。缺点：编译器无法优化这些常量，因为他们变成了run-time constants而不是compile-time constants。在编译阶段，对于<code>constant.cpp</code>以外的源文件，这些常量的值是未知的。</p>
</li>
<li><p>对于C++17，可以使用方法一，但是定义方式变为<code>inline const/constexpr</code>。inline variables允许重复定义，链接器会把重复定义视为同一个定义，而不会像方法一那样产生多个定义。但是改变一个全局变量的值，仍将引起所有相关源文件重新编译。</p>
</li>
</ol>
<h3 id="2-6-static"><a href="#2-6-static" class="headerlink" title="2.6 static"></a>2.6 static</h3><p>static在C++中的多种用法：</p>
<ol>
<li>static local variable：将局部变量的生命周期变为static，即变量定义时创建且只被创建一次，程序结束时销毁。应用场景：unique ID生成器，或在函数中提前创建好某个对象(static const local variable)每次调用不会重复创建。</li>
<li>static global variable：将全局变量的链接变成internal linkage。</li>
<li>static non-class function：将普通函数的链接变成internal linkage。</li>
</ol>
<h3 id="2-7-内联函数"><a href="#2-7-内联函数" class="headerlink" title="2.7 内联函数"></a>2.7 内联函数</h3><p>优点：利于编译器优化，提升性能。缺点：导致可执行文件变大，降低性能(缓存装不下)。</p>
<p>类或结构体中定义的函数和constexpr function都是内联函数。</p>
<p>比较现代的编译器会自行决定是否展开(inline expansion)某些函数来减少函数调用的开销(overhead)，不管函数是不是内联函数。不建议用户自己加上inline关键字，因为用户无法判断展开后是否一定会提升性能。</p>
</div><hr style="height:1px;margin:1rem 0"><div style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: -1rem"><div class="article-tags is-size-7 mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Interview/">Interview, </a><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><div></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold"><a class="link-muted" href="/2022/01/16/2022-01-17-algorithms-notes-chap2-4-application/">chap 2-3 分治算法-综合应用</a></h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-16T16:00:00.000Z" title="2022/1/16 18:00:00">2022-01-16</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style="color: grey; font-weight: normal; font-style: italic"><h2 id="1-满二叉树的数量"><a href="#1-满二叉树的数量" class="headerlink" title="1. 满二叉树的数量"></a>1. 满二叉树的数量</h2><p>定义满二叉树：所有节点要么有两个子节点，要么无子节点。设$B_n$表示共$n$节点的不同满二叉树的数量，则：</p>
<p>$$<br>B_{n+2}=\sum_{i=1}^{n+1}B_{i}B_{n+1-i}<br>$$</p>
<p>假设根节点固定，则$n+2$个节点的满二叉树数量，取决于根节点的左子树和右子树（都为满二叉树）的组合数量。使用数学归纳法可证，复杂度为$\Omega(2^n)$。我们可以使用额外的空间保存下$B_i$的值，这样可以减少重复计算次数。</p></div><hr style="height:1px;margin:1rem 0"><div style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: -1rem"><div class="article-tags is-size-7 mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Algorithms-Notes/">Algorithms-Notes</a></div><div><a class="article-more button is-small is-size-7" href="/2022/01/16/2022-01-17-algorithms-notes-chap2-4-application/#more">Read more</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold"><a class="link-muted" href="/2022/01/12/2022-01-13-algorithms-notes-chap2-3-fft/">chap 2-3 分治算法-多项式与快速傅里叶变换</a></h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-12T16:00:00.000Z" title="2022/1/12 18:00:00">2022-01-12</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style="color: grey; font-weight: normal; font-style: italic"><h2 id="1-信号处理"><a href="#1-信号处理" class="headerlink" title="1. 信号处理"></a>1. 信号处理</h2><p>在数字信号处理（Digital Signal Processing）领域中，经常使用到多项式乘法。信号通常是一个关于时间或位置的函数，比如捕获到的人的声音等等。数字信号处理要做的事情一般是，先对信号进行采样（sampling），使之变为离散信号；然后将离散信号输入到一个系统中（滤波器等等），最后得到系统的输出，我们称之为系统的响应（response）。</p></div><hr style="height:1px;margin:1rem 0"><div style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: -1rem"><div class="article-tags is-size-7 mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Algorithms-Notes/">Algorithms-Notes, </a><a class="link-muted mr-2" rel="tag" href="/tags/FFT/">FFT</a></div><div><a class="article-more button is-small is-size-7" href="/2022/01/12/2022-01-13-algorithms-notes-chap2-3-fft/#more">Read more</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold"><a class="link-muted" href="/2022/01/07/2022-01-08-algorithms-notes-chap2-2-sort_and_select/">chap 2-2 分治算法-排序和选择</a></h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-07T16:00:00.000Z" title="2022/1/7 18:00:00">2022-01-07</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style="color: grey; font-weight: normal; font-style: italic"><h2 id="1-快速排序（Quicksort）"><a href="#1-快速排序（Quicksort）" class="headerlink" title="1. 快速排序（Quicksort）"></a>1. 快速排序（Quicksort）</h2><p>排序算法经常用到分治策略。在现实中，最常用的排序算法当属快速排序。主要过程：首先进行<code>partition</code>操作，从数组中挑选一个元素作为主元pivot，将小于pivot的元素放置到它的左边，将大于pivot的元素放置到它的右边；然后递归地对pivot左右两边的数组进行<code>partition</code>。</p></div><hr style="height:1px;margin:1rem 0"><div style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: -1rem"><div class="article-tags is-size-7 mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Algorithms-Notes/">Algorithms-Notes, </a><a class="link-muted mr-2" rel="tag" href="/tags/Sorting/">Sorting, </a><a class="link-muted mr-2" rel="tag" href="/tags/Statistics/">Statistics</a></div><div><a class="article-more button is-small is-size-7" href="/2022/01/07/2022-01-08-algorithms-notes-chap2-2-sort_and_select/#more">Read more</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-4 is-size-4-mobile" style="font-weight: bold"><a class="link-muted" href="/2022/01/05/2022-01-06-algorithms-notes-chap2-1-master-theorem/">chap 2-1 分治算法-乘法、矩阵乘、主定理</a></h1><div class="article-meta is-size-7 level is-mobile" style="margin-top: -0.5rem; margin-bottom: 0.5rem"><div class="level-left"><i class="fas fa-calendar-alt"></i>  <span class="level-item"><time dateTime="2022-01-05T16:00:00.000Z" title="2022/1/5 18:00:00">2022-01-05</time></span><i class="fas fa-folder-open"></i>  <span class="level-item"><a class="link-muted" href="/categories/Blog/">Blog</a></span></div></div><hr style="height:1px;margin:1rem 0"><div class="content" style="color: grey; font-weight: normal; font-style: italic"><h2 id="1-分治（Divide-and-Conquer）"><a href="#1-分治（Divide-and-Conquer）" class="headerlink" title="1. 分治（Divide and Conquer）"></a>1. 分治（Divide and Conquer）</h2><p>分治算法是算法的重要分支之一，主要思想就是：</p>
<ol>
<li>自上而下把问题划分成几个小的子问题，每个子问题与原问题类型相同。</li>
<li>自下而上递归地解决子问题。</li>
<li>把子问题的解适当地组合成原问题的解。</li>
</ol>
<p>虽然分治法的核心结构是递归，但也不一定非得用函数递归来实现；递归法便于分析问题，迭代法可能却更为高效 。</p></div><hr style="height:1px;margin:1rem 0"><div style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: -1rem"><div class="article-tags is-size-7 mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Algorithms-Notes/">Algorithms-Notes, </a><a class="link-muted mr-2" rel="tag" href="/tags/Divide-and-Conquer/">Divide and Conquer</a></div><div><a class="article-more button is-small is-size-7" href="/2022/01/05/2022-01-06-algorithms-notes-chap2-1-master-theorem/#more">Read more</a></div></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Felix Feng"></figure><p class="title is-size-4 is-block" style="font-weight: bold">Felix Feng</p><p class="is-size-6 is-block" style="margin-top: 1rem">jsjhfx@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Posts</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading" style="font-weight: bold">Tags</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/2horse9sun" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/2horse9sun"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:jsjhfx@163.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Wechat" href="/felixxfeng"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-31T21:00:00.000Z">2023-09-01</time></p><p class="title"><a href="/2023/09/01/2023-09-01-notes-learncpp/">Learncpp学习笔记</a></p><p class="categories"><a href="/categories/Note/">Note</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-16T16:00:00.000Z">2022-01-16</time></p><p class="title"><a href="/2022/01/16/2022-01-17-algorithms-notes-chap2-4-application/">chap 2-3 分治算法-综合应用</a></p><p class="categories"><a href="/categories/Blog/">Blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-12T16:00:00.000Z">2022-01-12</time></p><p class="title"><a href="/2022/01/12/2022-01-13-algorithms-notes-chap2-3-fft/">chap 2-3 分治算法-多项式与快速傅里叶变换</a></p><p class="categories"><a href="/categories/Blog/">Blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-07T16:00:00.000Z">2022-01-07</time></p><p class="title"><a href="/2022/01/07/2022-01-08-algorithms-notes-chap2-2-sort_and_select/">chap 2-2 分治算法-排序和选择</a></p><p class="categories"><a href="/categories/Blog/">Blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-05T16:00:00.000Z">2022-01-05</time></p><p class="title"><a href="/2022/01/05/2022-01-06-algorithms-notes-chap2-1-master-theorem/">chap 2-1 分治算法-乘法、矩阵乘、主定理</a></p><p class="categories"><a href="/categories/Blog/">Blog</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithms-Notes/"><span class="tag">Algorithms-Notes</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cryptography/"><span class="tag">Cryptography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Divide-and-Conquer/"><span class="tag">Divide and Conquer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FFT/"><span class="tag">FFT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hashing/"><span class="tag">Hashing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Internet/"><span class="tag">Internet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Number-Theory/"><span class="tag">Number Theory</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sorting/"><span class="tag">Sorting</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Statistics/"><span class="tag">Statistics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-APP/"><span class="tag">Web APP</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/site-logo.png" alt="Felix Feng&#039;s Zone" height="28"></a><p class="is-size-7"><span>&copy; 2023 Felix Feng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>